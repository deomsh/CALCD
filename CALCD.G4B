!BAT
#-#+ CALCD.G4B v0.3.2 (20240613), by deomsh
if "%~1"=="" && echo CALCD.G4B v0.3.2 && goto :smallhelp
if /i "%~1"=="/?" && goto :help
if /i "%~1"=="--help" && goto :help
if /i "%~1"=="help" && goto :%~1
setlocal && set * && set result=%result% && set MR=%MR% && set round=%round% && set deci=%deci% && set digi=%digi% && set fix=%fix% && set resrnd=%resrnd% && set hex=%hex% && set R=%R% && set thsep=%thsep% && set roundup=%roundup% && set bin=%bin% && set bins=%bins%
debug status > nul ;; set /a dbgstat=%@retval% > nul
debug 1
debug msg=0
if %fix:~0,1%==- && set fix=
set shift=0 && set "echoMR= > nul" && set q=N
if not /i "%~1"=="--DBG" if not /i "%~2"=="--DBG" if not /i "%~3"=="--DBG" || set DBG=Y && set /a shift=%shift%+1
if not /i "%~1"=="--no-parse" if not /i "%~2"=="--no-parse" if not /i "%~3"=="--no-parse" || set /a shift=%shift%+1 ! set parse=Y
if not /i "%~1"=="--Q" if not /i "%~2"=="--Q" if not /i "%~3"=="--Q" || set q=Y && set /a shift=%shift%+1
if not /i "%~1"=="--echo" if not /i "%~2"=="--echo" if not /i "%~3"=="--echo" || set echoMR= && set "echor=call echo -n -e $[0x08]R=%^R%\x20\x20" && set /a shift=%shift%+1
if not /i "%~1"=="--echoM" if not /i "%~2"=="--echoM" if not /i "%~3"=="--echoM" || set echoMR= && set /a shift=%shift%+1
if not /i "%~1"=="--echoR" if not /i "%~2"=="--echoR" if not /i "%~3"=="--echoR" || set "echor=call echo -n -e $[0x08]R=%^R%\x20\x20" && set /a shift=%shift%+1
if not /i "%~1"=="--V" if not /i "%~2"=="--V" if not /i "%~3"=="--V" || debug msg=3 && set echoMR= && set "echor=call echo -n -e $[0x08]R=%^R%\x20\x20" && set /a shift=%shift%+1
if %shift%>=1 &; if %shift%==1 && shift ! if %shift%==2 && shift && shift ! if %shift%==3 && shift && shift && shift ! if %shift%==4 && shift && shift && shift && shift ! if %shift%==5 && shift && shift && shift && shift && shift ! if %shift%==6 && shift && shift && shift && shift && shift && shift ! if %shift%==7 && shift && shift && shift && shift && shift && shift && shift
if %q%==Y && set "echoMR= > nul" && set echor= && debug msg=0
set string=%*
set /a strinlen=%@retval% &; if %parse%==Y && if %strinlen%<=479 && set strinlen= && set string=%~1 ! if %parse%==Y && set "message=Abort: command-line of %strinlen% chars too long to be parsed" && set string= && set strinlen= && set parse= && set result= && goto :calcfpend ! set strinlen= && set string=%~1
call if not /i "%^string%"=="+" && call if not /i "%^string%"=="-" && call if not /i "%^string%"=="*" && call if not /i "%^string%"=="/" && call if not /i "%^string%"=="^" && call if not /i "%^string%"=="round" && call if not /i "%^string%"=="deci" && call if not /i "%^string%"=="digi" && call if not /i "%^string%"=="fix" && call if not /i "%^string%"=="inv" && call if not /i "%^string%"=="sqrt" && call if not /i "%^string%"=="sq" && call if not /i "%^string%"=="cbrt" && call if not /i "%^string%"=="cb" && call if not /i "%^string%"=="ln" && call if not /i "%^string%"=="log" && call if not /i "%^string%"=="ex" && call if not /i "%^string%"=="10x" && call if not /i "%^string%"=="hex" && call if not /i "%^string%"=="thsep" && call if not /i "%^string%"=="r" && if not /i "%~2"=="r" && if not /i "%~3"=="r" && call if not /i "%^string%"=="rounddown" && call if not /i "%^string%"=="roundup" && set resrnd= && set string= ! set string=
if exist R && set result=%R% && set lastrnd=%resrnd% ! if exist result && set R=%result% && set resrnd= ! set R=0 && set result=0 && set resrnd=
if not exist MR && set MR=0 && set memrnd=
if not exist echoMR && echo -n -e $[0x08]MR=%MR%\x20
%echor%
if %parse%==Y &; call :parsestring %* &; if exist STRING && call :calcfprestart %STRING% ! call :calcfprestart %* &; endlocal && set result=%result% && set rounded=%rounded% && set MR=%MR% && set "message=%message%" && set resrnd=%lastrnd% && set R=%R% && goto :eof
:calcfprestart
if exist result && set R=%result% && set resrnd=%lastrnd% ! set R=0 && set result=0 && set resrnd= &; if "%R:~0,3"=="0b " && setlocal && call :join goback %R% \\ &; if exist result && endlocal && set R=%result% ! endlocal && set "message=%message" && set result= && goto :calcfpend
if /i "%~1"=="mc" && set MR=0 && set memrnd= && echo -e -n $[0x08]MR=0\x20\x20%echoMR% && set memecho=Y && set result=%R% && set lastrnd=%resrnd% && shift && goto :calcfploop
if /i "%~1"=="r" &; if "%~2"=="" && call :lastinput lastinput "%R%" && goto :calcfpend ! if exist R && set result=%R% && set lastrnd=%resrnd% && set resrnd= && shift && goto :calcfploop ! set "message=R does not exist" && goto :calcfpend
if /i "%~1"=="r!" &; if "%~2"=="" && call :lastinput lastinput "%R%" && goto :calcfpend ! if exist R && set lastrnd=%resrnd% && set resrnd= && call :lastinput lastinput %R%! && shift && goto :calcfploop ! set "message=R does not exist" && goto :calcfpend
if /i "%~1"=="srm" && set mem2rnd=%lastrnd% && set lastrnd=%memrnd% &; if "%~2"=="" && set result=%MR% && set MR=%R% && set memrnd=%mem2rnd% && goto :calcfpend ! set result=%MR% && set MR=%R% && set memrnd=%mem2rnd% && echo -e -n $[0x08]MR=%R%\x20\x20%echoMR% && set memecho=Y && set memecho2=Y && shift && goto :calcfploop
if /i "%~1"=="mr" &; if "%~2"=="" && set lastrnd=%memrnd% && call :lastinput lastinput "%MR%" && goto :calcfpend ! set result=%MR% && set lastrnd=%memrnd% && shift && goto :calcfploop
if /i "%~1"=="ms" && set MR=%R% && set memrnd=%lastrnd% && echo -e -n $[0x08]MR=%R%\x20\x20%echoMR% && set memecho=Y &; if "%~2"=="" && goto :calcfpend ! shift && goto :calcfploop
if /i "%~1"=="mp" && call :+ + "%MR%" "%R%" &; if exist result && echo -e -n $[0x08]MR=%result%\x20\x20%echoMR% && set memecho=Y && set MR=%result% && set memrnd=%lastrnd% && set result=%R% && shift && goto :calcfploop ! goto :calcfpend
if /i "%~1"=="mn" && call :- - "%MR%" "%R%" &; if exist result && echo -e -n $[0x08]MR=%result%\x20\x20%echoMR% && set memecho=Y && set MR=%result% && set memrnd=%lastrnd% && set result=%R% && shift && goto :calcfploop ! goto :calcfpend
if "%~1"=="" && goto :calcfpend
if /i "%~2"=="ms" && set memrnd=%lastrnd% && set MR=%~1 && echo -e -n $[0x08]MR=%~1\x20\x20%echoMR% && set memecho=Y &; if not "%~3"=="" && set result=%~1 && shift && shift && goto :calcfploop ! goto :calcfpend
if /i "%~2"=="mp" && call :+ + "%MR%" %~1 &; if exist result && echo -e -n $[0x08]MR=%result%\x20\x20%echoMR% && set memecho=Y && set MR=%result% && set memrnd=%lastrnd% && set result=%~1 && shift && shift && goto :calcfploop ! goto :calcfpend
if /i "%~2"=="mn" && call :- - "%MR%" %~1 &; if exist result && echo -e -n $[0x08]MR=%result%\x20\x20%echoMR% && set memecho=Y && set MR=%result% && set memrnd=%lastrnd% && set result=%~1 && shift && shift && goto :calcfploop ! goto :calcfpend
if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" |; call :"%~1" "%~1" %~2 %~3 &; if not "%~4"=="" && shift && shift && shift && set rounded= && set lastrnd= && goto :calcfploop ! set rounded= && set lastrnd= && goto :calcfpend
if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" || goto :%~1
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; call :%~1 %~1 "%R%" %~2 &; if exist result && if not "%~2"=="" && shift && goto :calcfprestart ! goto :calcfpend
if /i "%~1"=="inv" && call :/ / 1 "%R%" &; if exist result && if not "%~2"=="" && shift && goto :calcfprestart ! goto :calcfpend
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; if not "%~2"=="" && set result= && call :%~1 %~1 "%R%" %~2 &; if not "%~3"=="" && shift && shift && goto :calcfploop ! goto :calcfpend
if not /i "%~2"=="sqrt" if not /i "%~2"=="inv" if not /i "%~2"=="hex" if not /i "%~2"=="cbrt" if not /i "%~2"=="sq" if not /i "%~2"=="cb" if not /i "%~2"=="bin" if not /i "%~2"=="bins" if not /i "%~2"=="ln" if not /i "%~2"=="log" if not /i "%~2"=="ex" if not /i "%~2"=="10x" if not /i "%~2"=="abs" |; call :%~2 %~2 %~1 %~3 &; if exist result && if not "%~3"=="" && shift && shift && goto :calcfploop ! goto :calcfpend
if not "%~2"=="+" if not "%~2"=="-" if not "%~2"=="*" if not "%~2"=="/" if not "%~2"=="^" if not /i "%~2"=="round" if not /i "%~2"=="deci" if not /i "%~2"=="digi" if not /i "%~1"=="fix" if not /i "%~2"=="rounddown" if not /i "%~2"=="roundup" |; if not "%~3"=="" && set result= && call :%~2 %~2 %~1 %~3 &; if not "%~4"=="" && shift && shift && shift && goto :calcfploop ! goto :calcfpend
if not /i "%~2"=="fix" |; if not "%~3"=="" && set result= && call :%~2 %~2 %~1 %~3 %~4 &; if not "%~4"=="" && shift && shift && shift && goto :calcfploop ! goto :calcfpend
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; if "%~2"=="" && set thsep=Y && goto :calcfpend ! shift && goto :calcfprestart
if not /i "%~2"=="ts" if not /i "%~2"=="tsp" if not /i "%~2"=="tsep" if not /i "%~2"=="ths" if not /i "%~2"=="thsp" if not /i "%~2"=="thsep" if not /i "%~2"=="thssep" |; if "%~3"=="" && call :thsep nothsepar %~1 && set thsep=Y && goto :calcfpend ! set result=%~1 && shift && shift && goto :calcfprestart
if "%~2"=="" && call :lastinput lastinput "%~1" &; goto :calcfpend
set "message=Abort: 'some' argument is missing or wrong, check '%~1' or '%~2'" && goto :calcfpend
:calcfploop
if not exist result && goto :calcfpend ! set R=%result% && set resrnd=%lastrnd%
if "%~1"=="" && goto :calcfpend
%echor%
if /i "%~1"=="mc" && set MR=0 && set memrnd= && echo -e -n $[0x08]MR=0\x20\x20%echoMR% && set memecho=Y && shift && goto :calcfploop
if "/i %~1"=="ms" && set memrnd=%lastrnd% && echo -e -n $[0x08]MR=%result%\x20\x20%echoMR% && set memecho=Y && set MR=%result% && shift &; if "%~2"=="" && goto :calcfpend ! goto :memorydone
if /i "%~1"=="mp" && set memory2=%result% && call :+ + "%MR%" "%result%" &; if exist result && echo -e -n $[0x08]MR=%result%\x20\x20%echoMR% && set memecho=Y && set MR=%result% && set memrnd=%lastrnd% && set result=%memory2% && shift && goto :memorydone ! goto :calcfpend
if /i "%~1"=="mn" && set memory2=%result% && call :- - "%MR%" "%result%" &; if exist result && echo -e -n $[0x08]MR=%result%\x20\x20%echoMR% && set memecho=Y && set MR=%result% && set memrnd=%lastrnd% && set result=%memory2% && shift && goto :memorydone ! goto :calcfpend
:memorydone
if /i "%~1"=="mr" && if "%~2"=="" && set lastrnd=%memrnd% && call :lastinput lastinput "%MR%" && goto :calcfpend
if "%~1"=="" && goto :calcfpend
if not /i "%~1"=="mc" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="mr!" if not /i "%~1"=="r" if not /i "%~1"=="r!" || goto :calcfprestart
if "%~1"=="\\" && if /i "%~2"=="mc" && set MR=0 && set memrnd= && echo -e -n $[0x08]MR=0\x20\x20%echoMR% && set memecho=Y && shift &; if "%~3"=="" && goto :calcfpend ! set memecho=Y && goto :calcfprestart
if "%~1"=="\\" && if /i "%~2"=="ms" && set MR=%R% && set memrnd=%lastrnd% && echo -e -n $[0x08]MR=%result%\x20\x20%echoMR% && set memecho=Y && shift &; if "%~3"=="" && goto :calcfpend ! goto :calcfprestart
if "%~1"=="\\" && if /i "%~2"=="mp" && set memrnd=%lastrnd% && set memory2=%result% && call :+ + "%MR%" "%result%" &; if exist result && echo -e -n $[0x08]MR=%result%\x20\x20%echoMR% && set memecho=Y && set MR=%result% && set memrnd=%lastrnd% && set result=%memory2% && shift && shift && goto :calcfprestart ! goto :calcfpend
if "%~1"=="\\" && if /i "%~2"=="mn" && set memrnd=%lastrnd% && set memory2=%result% && call :- - "%MR%" "%result%" &; if exist result && echo -e -n $[0x08]MR=%result%\x20\x20%echoMR% && set memecho=Y && set MR=%result% && set memrnd=%lastrnd% && set result=%memory2% && shift && shift && goto :calcfprestart ! goto :calcfpend
if "%~1"=="\\" && if /i "%~2"=="mr" && if "%~3"=="" && set result=%MR% && set lastrnd=%memrnd% && goto :calcfpend
if "%~1"=="\\" && shift && goto :calcfprestart
if /i "%~1"=="srm" && set mem2rnd=%lastrnd% && set lastrnd=%memrnd% && set memory2=%result% && set result=%MR% &; set MR=%memory2% && set memrnd=%mem2rnd% && echo -e -n $[0x08]MR=%memory2%\x20\x20%echoMR% && set memecho=Y && set memecho2=Y &; if "%~2"=="" && goto :calcfpend ! shift && goto :calcfploop
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; call :%~1 %~1 "%result%" %~2 &; if exist result && if not "%~2"=="" && shift && goto :calcfploop ! goto :calcfpend
if /i "%~1"=="inv" && call :/ / 1 "%result%" &; if exist result && if not "%~2"=="" && shift && goto :calcfploop ! goto :calcfpend
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; if not "%~2"=="" && set result= && call :%~1 %~1 "%result%" %~2 &; if not "%~3"=="" && shift && shift && goto :calcfploop ! goto :calcfpend
if not /i "%~1"=="fix" |; if not "%~2"=="" && set result= && call :%~1 %~1 "%result%" %~2 %~3 &; if not "%~3"=="" && shift && shift && goto :calcfploop ! goto :calcfpend
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; if "%~2"=="" && set thsep=Y && goto :calcfpend ! shift
if "%~2"=="" && set "message=Abort: 'some' argument is missing or wrong, check '%~1'" && goto :calcfpend ! goto :calcfprestart
:calcfpend
if exist result && if "%result:~-1,1%"=="!" && call :lastinput lastinput %result%
if exist result && set R=%result% && set resrnd=%lastrnd%
if exist echor &; setlocal && call :"==" "==" "%R%" "%result%" &; if %result%==1 && endlocal && %echor% ! endlocal
if exist result && if %rounded%==Y && if exist digi && set round= && set deci= && set vardigi=%digi% && call :digi digi "%result%" %digi% &; set digi=%vardigi%
if exist result && if exist fix && set varfix=%fix% && set round= && set deci= && set fixed= && call :fix fix "%result%" "%fix%" &; set fix=%varfix%
if exist result && if exist deci && set vardeci=%deci% && call :deci deci "%result%" %deci% &; set deci=%vardeci%
if exist result && if exist round && set varround=%round% && call :round round "%result%" %round% &; set round=%varround%
if exist result && if exist roundup && set varrndup=%roundup% && call :roundup roundup "%result%" %roundup% &; set roundup=%varrndup%
if exist result && if exist hex && set varhex=%hex% && set fixed= && call :hex hex "%result%" &; set hex=%varhex%
if exist result && if exist bin && set varbin=%bin% && set fixed= && call :bin bin "%result%" &; set bin=%varbin%
if exist result && if exist bins && set varbin=%bins% && set fixed= && call :bins bins "%result%" &; set bins=%varbin%
if %q%==N &; if exist message && set result= &; if exist echoMR if not exist echor || echo && echo $[0x0F]%message% ! echo $[0x0F]%message% &; if %message:~0,5%==Abort && call :smallhelp
if exist result && if not exist fixed && call Fn.11 "%result%" "." && call :stripzerosafter "%result%" &; if not exist result && set result=0 ! if %result:~-1,1%==. && set result=%result:~0,-1%
if %q%==N && if exist echor && if %rounded%==Y && setlocal &; if %lastrnd%==1 && set lastrnd=up ! set lastrnd=down &; echo -e -n $[0x08]rounded=%rounded%\x20last=%lastrnd%\x20 && endlocal
if %q%==N && if not exist message && if exist fix && echo -e -n $[0x08]fix=%fix%\x20
if %q%==N && if not exist message && if exist digi && echo -e -n $[0x08]digi=%digi%\x20
if %q%==N && if not exist message && if exist round && echo -e -n $[0x08]round=%round%\x20
if %q%==N && if not exist message && if exist deci && echo -e -n $[0x08]deci=%deci%\x20
if %q%==N && if not exist message && if exist hex && echo -e -n $[0x08]hex=%hex%\x20
if %q%==N && if not exist message && if exist bin && echo -e -n $[0x08]bin=%bin%\x20
if %q%==N && if not exist message && if exist bins && echo -e -n $[0x08]bins=%bins%\x20
if %q%==N && if not exist message &; if not exist echoMR && echo -e -n $[0x08]MR=%MR%$[]\x20
if %q%==N && if not exist message &; if exist echoMR if not exist echor if not exist fix if not exist digi if not exist round if not exist deci if not exist hex if %q%==N && if not exist message &; if exist echoMR if not exist echor if not exist fix if not exist digi if not exist round if not exist deci if not exist hex if not exist bin || echo
if exist result && if exist thsep && call :thsep thsep %result%
if %q%==N &; if exist result && echo result=%result%
if "%R:~0,3%"=="0b " &; setlocal && call :join goback %R% \\ &; if exist result && endlocal && set R=%result% ! endlocal && set "message=%message" && set result=
#bad#call Fn.11 "%R%" "\x20" &; call Fn.11 "%R:~0,4%" "0b\x201" ! call Fn.11 "%R:~0,4%" "0b\x200" |; setlocal && call :join goback %R% \\ &; endlocal && set R=%result%
if exist debugsts && debug %debugsts% > nul
if %q%==N && debug msg=3
if %parse%==Y && goto :eof
endlocal && set result=%result% && set rounded=%rounded% && set MR=%MR% && set "message=%message%" && set resrnd=%lastrnd% && set R=%R%
goto :eof
::
:addzerosafter
set reslen=%~1
set result=%~3
:addzerosafterloop
if not %reslen>=%~2 && set result=%result%%0 &; set /a reslen=%@retval% &; if not %reslen%>=%~2 && goto :addzerosafterloop ! set reslen= && goto :eof
::
:addzerosbefore
set reslen=%~1
set result=%~3
:addzerosbeforeloop
if not %reslen>=%~2 && set result=0%result% &; set /a reslen=%@retval% &; if not %reslen%>=%~2 && goto :addzerosbeforeloop ! set reslen= && goto :eof
::
:stripzerosbefore
if %~n1==0 && if %~x1==0 && set result= && goto :eof
set result=%~1
:stripzerosbeforeloop
if not %result:~0,2%==0x &; if %result:~0,1%==0 && set result=%result:~1% && goto :stripzerosbeforeloop ! goto :eof
if %result:~0,2%==0x &; if %result:~2,1%==0 && set result=0x%result:~3% && goto :stripzerosbeforeloop ! goto :eof
::
:stripzerosafter
if %~n1==0 && if %~x1==0 && set result= && goto :eof
if %~x1==0 && set result=%~n1 && goto :eof
set result=%~1
:stripzerosafterloop
if %result:~-1,1%==0 && set result=%result:~0,-1% && goto :stripzerosafterloop ! goto :eof
::
:operatorsinput
set "function=%~1" && shift
call Fn.11 "%~x1%~x2" "," && set "message=Abort '%function%': no comma allowed in decimals, check '%~1' or '%~2'" && goto :eof
call Fn.11 "%~1%~2" "*" && set "message=Abort '%function%': bad input, check '%~1' or '%~2'" && goto :eof
call Fn.11 "%~1%~2" "/" && set "message=Abort '%function%': bad input, check '%~1' or '%~2'" && goto :eof
call Fn.11 "%~1%~2" "%" && set "message=Abort '%function%': bad input, check '%~1' or '%~2'" && goto :eof
call Fn.11 "%~1%~2" "|" && set "message=Abort '%function%': bad input, check '%~1' or '%~2'" && goto :eof
call Fn.11 "%~1%~2" "<" && set "message=Abort '%function%': bad input, check '%~1' or '%~2'" && goto :eof
call Fn.11 "%~1%~2" ">" && set "message=Abort '%function%': bad input, check '%~1' or '%~2'" && goto :eof
set /l N1=%~n1 &; if %N1:~-1,1%==: && set "message=Bad input: no operators or +/- possible inside fractions, check '%N1%'" && goto :eof ! if "%N1:~0,2%"=="--" && set N1=%N1:~2% && set sign1=1 ! if "%N1:~0,2%"=="+-" && set N1=%N1:~2% && set sign1=-1 ! if "%N1:~0,2%"=="-+" && set N1=%N1:~2% && set sign1=-1 ! if "%N1:~0,2%"=="++" && set N1=%N1:~2% && set sign1=1 ! if "%N1:~0,1%"=="-" && set N1=%N1:~1% && set sign1=-1 ! if "%N1:~0,1%"=="+" && set N1=%N1:~1% && set sign1=1 ! set N1=%N1% && set sign1=1
if not exist N1 && set N1=0 && set N1len=0 ! if "%N1:~0,2%"=="0x" && if %N1:~2%==0 && set N1=0 && set N1len=0
if not %N1%==0 && call :stripzerosbefore "%N1%" &; if exist result && set N1=%result% &; set /a N1len=%@retval% && set result=
if "%N1:~0,2%"=="0x" && call Fn.11 "%N1%" "," &; set "message=Abort '%function%': wrong comma, use dot for decimals. Check '%~1'" && goto :eof
if "%N1:~0,2%"=="0b" && call Fn.11 "%N1%" "," &; set "message=Abort '%function%': wrong comma, use dot for decimals. Check '%~1'" && goto :eof
if "%N1:~0,2%"=="0b" && if "%N1:~2,1%"==" " && if not "%N1:~3,1%"=="" &; call :join goback %N1% \\ &; if exist message && goto :eof ! if exist result && set N1=%result% && set result= ! goto :eof
call Fn.11 "%N1%" ":" |; if "%N1:~0,2%"=="0b" &; if %sign1%==-1 && set sign1=1 && call :bin2decimal "-%N1%" ! call :bin2decimal "%N1%" &; if %result:~0,1%==- && set N1=%result:~1% && set sign1=-1 ! set N1=%result%
call Fn.11 "%N1%" "," && if %N1len%>=5 &; if %N1:~-4,1%==, && set N1=%N1:~0,-4%%%N1:~-3,3% &; if %N1:~-7,1%==, && set N1=%N1:~0,-7%%%N1:~-6,6% &; if %N1:~-10,1%==, && set N1=%N1:~0,-10%%%N1:~-9,9% &; if %N1:~-13,1%==, && set N1=%N1:~0,-13%%%N1:~-12,12% &; if %N1:~-16,1%==, && set N1=%N1:~0,-16%%%N1:~-15,15% &; if %N1:~-19,1%==, && set N1=%N1:~0,-19%%%N1:~-18,18%
call Fn.11 "%N1%" "," &; set "message=Abort '%function%': wrong comma, use dot for decimals. Check '%~1'" && goto :eof
call Fn.11 "%N1%" ":" && if not "%~x1"=="" &; set "message=Abort '%function%': wrong comma, use dot for decimals. Check '%~1'" && goto :eof
if not %N1:~-1,1%==k if not %N1:~-1,1%==m if not %N1:~-1,1%==g |; if not /i "%N1:~0,2%"=="pi" && if not /i "%N1:~-3,2%"=="pi" && if not /i "%N1:~0,2%"=="en" && if not /i "%N1:~-2,2%"=="en" && set N1=%N1:~0,-1% && set N1kmg=%N1:~-1,1% ! set d1kmg=%N1:~-1,1% && set N1=%N1:~0,-1%
if /i "%N1%"=="pi" &; set N1=1 && set epi1=pi
if /i "%N1:~-2,2%"=="pi" && set N1=%N1:~0,-2% && set epi1=pi
if /i "%N1%"=="en" &; set N1=1 && set epi1=e
if /i "%N1:~-2,2%"=="en" && set N1=%N1:~0,-2% && set epi1=e
call Fn.11 "%N1%" ":" |; if "%N1:~0,2%"=="0x" &; if %N1:~0,3%>=0x8 && if %N1len%==18 &; set /a N1=%N1% &; set /a N1len=%@retval% &; set N1=%N1:~1% && set /a N1len=%N1len%-1 &; if %sign1%==-1 && set sign1=1 ! set sign1=-1
call Fn.11 "%N1%" ":" &; call call Fn.11 "%^N1%" "-" && set bad=- ! call call Fn.11 "%^N1%" "k" && set bad=k ! call call Fn.11 "%^N1%" "m" && set bad=m ! call call Fn.11 "%^N1%" "g" && set bad=g ! call call Fn.11 "%^N1%" "!" && set bad=! ! call call Fn.11 "%^N1%" "r" && set bad=r ! call call Fn.11 "%^N1%" "mr" && set bad=mr ! call call Fn.11 "%^N1%" "en" && set bad=en ! call call Fn.11 "%^N1%" "pi" && set bad=pi &; if exist bad && set "message=Bad input: '%bad%' not allowed inside fraction '%N1%'" && goto :eof
call Fn.11 "%N1%" ":" &; setlocal && set FR=%N1% &; call :fraction2decimal fraction "%FR%" &; if exist N1kmg && call :* * "%result%" "1%N1kmg%" ! set N1kmg= &; call :splitnumber "%result%" &; if exist message && endlocal && set "message=%message%" && goto :eof ! endlocal && set N1=%N% && set decimal1=%decimals% && set numdeci1=%numdecis% && set FR1=%FR% && set N1kmg=
call Fn.11 "%~1" "," && set N1=%N1%%%N1kmg% ! set N1=%N1%%%N1kmg% &; set /a N1len=%@retval%
debug msg=1 ;; if exist N1 && calc %N1% | set calc= ;; debug msg=0 ;; if exist N1 && if not exist calc && set "message=Operation '%function%' out of range, check first number '%~1'" && goto :eof ! if exist N1 && if "%calc:~0,1%"=="-" && set "message=Operation '%function%' out of range, check first number '%~1'" && set calc= && goto :eof ! set calc=
if "%N1:~0,2%"=="0x" && if not %N1len%<=17 &; if %N1len%==18 && if not %N1:~2,1%<=7 && set "message=Operation '%function%' out of range, check first number '%~1'" && goto :eof ! if not %N1len%<=18 && set "message=Operation '%function%' out of range, check first number '%~1'" && goto :eof
call Fn.11 "%N1%" "+" && set "message=Abort '%function%': bad input, check '%~1'" && goto :eof
call Fn.11 "%N1%" "-" && set "message=Abort '%function%': bad input, check '%~1'" && goto :eof
if not %N1%==0 && set /a N1=%N1% &; if %N1%==0 && set "message=Abort '%function%': bad input in '%~1'" && goto :eof
if %epi1%==pi &; setlocal &; if exist decimal1 && call :* * "%N1%.%decimal1%" "3.141592653589793238" ! call :* * "%N1%" "3.141592653589793238" &; call :splitnumber "%result%" &; if exist message && endlocal && set "message=%message%" && goto :eof ! endlocal && set N1=%N% && set decimal1=%decimals% && set numdeci1=%numdecis% && set epi1=Y
if %epi1%==e &; setlocal &; if exist decimal1 && call :* * "%N1%.%decimal1%" "2.718281828459045235" ! call :* * "%N1%" "2.718281828459045235" &; call :splitnumber "%result%" &; if exist message && endlocal && set "message=%message%" && goto :eof ! endlocal && set N1=%N% && set decimal1=%decimals% && set numdeci1=%numdecis% && set epi1=Y
set N1=%N1% &; set /a N1len=%@retval%
if not %epi1%==Y && if not exist FR1 && set /l decimal1=%~x1 &; if not exist decimal1 && set numdeci1=0 ! if "%decimal1%"=="." && set decimal1= && set numdeci1=0 ! set decimal1=%decimal1:~1%
if exist decimal1 &; if not %decimal1:~-1,1%==k if not %decimal1:~-1,1%==m if not %decimal1:~-1,1%==g |; set decimal1=%decimal1:~0,-1% && set d1kmg=%decimal1:~-1,1% &; if exist N1kmg && set "message=Operation '%function%' not allowed, check first number '%~1'" && goto :eof
if exist decimal1 &; if %decimal1:~-1,1%==e && set decimal1=%decimal1:~0,-1% && set d1epi=2.718281828459045235 ! if %decimal1:~-2,2%==pi && set decimal1=%decimal1:~0,-2% && set d1epi=3.141592653589793238 &; if exist epi1 && set "message=Operation '%function%' not allowed, check first number '%~1'" && goto :eof
if exist decimal1 && call Fn.11 "%decimal1%" "+" && set "message=Abort '%function%': bad input, check '%~1'" && goto :eof
if exist decimal1 && call Fn.11 "%decimal1%" "-" && set "message=Abort '%function%': bad input, check '%~1'" && goto :eof
if exist decimal1 &; if %decimal1%==0 && set decimal1= && set numdeci1=0 ! call Fn.11 "%decimal1%" "G" && set "message=Abort '%function%': bad input in '%~1'" && goto :eof ! call Fn.11 "%decimal1%" "g" && set "message=Abort '%function%': bad input in '%~1'" && goto :eof ! call Fn.11 "%decimal1%" "M" && set "message=Abort '%function%': bad input in '%~1'" && goto :eof ! call Fn.11 "%decimal1%" "m" && set "message=Abort '%function%': bad input in '%~1'" && goto :eof ! call Fn.11 "%decimal1%" "K" && set "message=Abort '%function%': bad input in '%~1'" && goto :eof ! call Fn.11 "%decimal1%" "k" && set "message=Abort '%function%': bad input in '%~1'" && goto :eof
if exist decimal1 && set decimal1=%decimal1:~0,18% &; set /a numdeci1=%@retval% && if %decimal1:~-1,1%==0 && if not exist fix && call :stripzerosafter "%decimal1%" &; set decimal1=%result% && set result= &; if exist decimal1 && set decimal1=%decimal1% &; set /a numdeci1=%@retval%
if not exist decimal1 && set numdeci1=0
if exist d1epi &; setlocal && set epi=%d1epi% && set d1epi= &; call :* * "%N1%.%decimal1%" "%epi%" &; call :splitnumber "%result%" &; if exist message && endlocal && set "message=%message%" && goto :eof ! endlocal && set N1=%N% && set decimal1=%decimals% && set numdeci1=%numdecis% && set d1epi=%d1epi%
if exist d1kmg &; setlocal && set kmg=%d1kmg% && set d1kmg= &; call :* * "%N1%.%decimal1%" "1%kmg%" &; call :splitnumber "%result%" &; if exist message && endlocal && set "message=%message%" && goto :eof ! endlocal && set N1=%N% && set decimal1=%decimals% && set numdeci1=%numdecis% && set d1kmg=%d1kmg%
set epi1= && if "%~2"=="" && goto :eof
set /l N2=%~n2 &; if %N2:~-1,1%==: && set "message=Bad input: no operators or +/- possible inside fractions, check '%N2%'" && goto :eof ! if "%N2:~0,2%"=="--" && set N2=%N2:~2% && set sign2=1 ! if "%N2:~0,2%"=="+-" && set N2=%N2:~2% && set sign2=-1 ! if "%N2:~0,2%"=="-+" && set N2=%N2:~2% && set sign2=-1 ! if "%N2:~0,2%"=="++" && set N2=%N2:~2% && set sign2=1 ! if "%N2:~0,1%"=="-" && set N2=%N2:~1% && set sign2=-1 ! if "%N2:~0,1%"=="+" && set N2=%N2:~1% && set sign2=1 ! set N2=%N2% && set sign2=1
if not exist N2 && set N2=0 && set N2len=0 ! if "%N2:~0,2%"=="0x" && if %N2:~2%==0 && set N2=0 && set N2len=0
if not %N2%==0 && call :stripzerosbefore "%N2%" &; if exist result && set N2=%result% &; set /a N2len=%@retval% && set result=
if "%N2:~0,2%"=="0x" && call Fn.11 "%N2%" "," &; set "message=Abort '%function%': wrong comma, use dot for decimals. Check '%~2'" && goto :eof
if "%N2:~0,2%"=="0b" && call Fn.11 "%N2%" "," &; set "message=Abort '%function%': wrong comma, use dot for decimals. Check '%~1'" && goto :eof
if "%N2:~0,2%"=="0b" && if "%N2:~2,1%"==" " && if not "%N2:~3,1%"=="" &; call :join goback %N2% \\ &; if exist message && goto :eof ! if exist result && set N2=%result% && set result= ! goto :eof
call Fn.11 "%N2%" ":" |; if "%N2:~0,2%"=="0b" &; if %sign2%==-1 && set sign2=1 && call :bin2decimal "-%N2%" ! call :bin2decimal "%N2%" &; if %result:~0,1%==- && set N2=%result:~1% && set sign2=-1 ! set N2=%result%
call Fn.11 "%N2%" "," && if %N2len%>=5 &; if %N2:~-4,1%==, && set N2=%N2:~0,-4%%%N2:~-3,3% &; if %N2:~-7,1%==, && set N2=%N2:~0,-7%%%N2:~-6,6% &; if %N2:~-10,1%==, && set N2=%N2:~0,-10%%%N2:~-9,9% &; if %N2:~-13,1%==, && set N2=%N2:~0,-13%%%N2:~-12,12% &; if %N2:~-16,1%==, && set N2=%N2:~0,-16%%%N2:~-15,15% &; if %N2:~-19,1%==, && set N2=%N2:~0,-19%%%N2:~-18,18%
call Fn.11 "%N2%" "," &; set "message=Abort '%function%': wrong comma, use dot for decimals. Check '%~2'" && goto :eof
call Fn.11 "%N2%" "+" && set "message=Abort '%function%': bad input, check '%~2'" && goto :eof
call Fn.11 "%N2%" "-" && set "message=Abort '%function%': bad input, check '%~2'" && goto :eof
call Fn.11 "%N2%" ":" && if not "%~x2"=="" &; set "message=Abort '%function%': bad input, check '%~2'" && goto :eof
if not %N2:~-1,1%==k if not %N2:~-1,1%==m if not %N2:~-1,1%==g |; if not /i "%N2:~0,2%"=="pi" && if not /i "%N2:~-3,2%"=="pi" && if not /i "%N2:~0,2%"=="en" && if not /i "%N2:~-2,2%"=="en" && set N2=%N2:~0,-1% && set N2kmg=%N2:~-1,1% ! set d2kmg=%N2:~-1,1% && set N2=%N2:~0,-1%
if /i "%N2%"=="pi" &; set N2=1 && set epi2=pi
if /i "%N2:~-2,2%"=="pi" && set N2=%N2:~0,-2% && set epi2=pi
if /i "%N2%"=="en" &; set N2=1 && set epi2=e
if /i "%N2:~-2,2%"=="en" && set N2=%N2:~0,-2% && set epi2=e
call Fn.11 "%N2%" ":" |; if "%N2:~0,2%"=="0x" &; if %N2:~0,3%>=0x8 && if %N2len%==18 &; set /a N2=%N2% &; set /a N2len=%@retval% &; set N2=%N2:~1% && set /a N2len=%N2len%-1 &; if %sign2%==-1 && set sign2=1 ! set sign2=-1
call Fn.11 "%N2%" ":" &; call call Fn.11 "%^N2%" "-" && set bad=- ! call call Fn.11 "%^N2%" "k" && set bad=k ! call call Fn.11 "%^N2%" "m" && set bad=m ! call call Fn.11 "%^N2%" "g" && set bad=g ! call call Fn.11 "%^N2%" "!" && set bad=! ! call call Fn.11 "%^N2%" "r" && set bad=r ! call call Fn.11 "%^N2%" "mr" && set bad=mr ! call call Fn.11 "%^N2%" "en" && set bad=en ! call call Fn.11 "%^N2%" "pi" && set bad=pi &; if exist bad && set "message=Bad input: '%bad%' not allowed inside fraction '%N2%'" && goto :eof
call Fn.11 "%N2%" ":" &; setlocal && set FR=%N2% &; call :fraction2decimal fraction "%FR%" &; if exist N2kmg && call :* * "%result%" "1%N2kmg%" ! set N2kmg= &; call :splitnumber "%result%" &; if exist message && endlocal && set "message=%message%" && goto :eof ! endlocal && set N2=%N% && set decimal2=%decimals% && set numdeci2=%numdecis% && set FR2=%FR% && set N2kmg=
call Fn.11 "%~2" "," && set N2=%N2%%%N2kmg% ! set N2=%N2%%%N2kmg% &; set /a N2len=%@retval%
debug msg=1 ;; if exist N2 && calc %N2% | set calc= ;; debug msg=0 ;; if exist N2 && if not exist calc && set "message=Operation '%function%' out of range, check first number '%~2'" && goto :eof ! if exist N2 && if "%calc:~0,1%"=="-"  && set "message=Operation '%function%' out of range, check first number '%~2'" && set calc= && goto :eof ! set calc=
if not %N2%==0 && set /a N2=%N2% &; if %N2%==0 && set "message=Abort '%function%': bad input in '%~2'" && goto :eof
if %epi2%==pi &; setlocal &; if exist decimal2 && call :* * "%N2%.%decimal2%" "3.141592653589793238" ! call :* * "%N2%" "3.141592653589793238" &; call :splitnumber "%result%" &; if exist message && endlocal && set "message=%message%" && goto :eof ! endlocal && set N2=%N% && set decimal2=%decimals% && set numdeci2=%numdecis% && set epi2=Y
if %epi2%==e &; setlocal && if exist decimal2 && call :* * "%N2%.%decimal2%" "2.718281828459045235" ! call :* * "%N2%" "2.718281828459045235" &; call :splitnumber "%result%" &; if exist message && endlocal && set "message=%message%" && goto :eof ! endlocal && set N2=%N% && set decimal2=%decimals% && set numdeci2=%numdecis% && set epi2=Y
set N2=%N2% &; set /a N2len=%@retval%
if not %epi2%==Y && if not exist FR2 && set /l decimal2=%~x2 &; if not exist decimal2 && set numdeci2=0 && goto :eof ! if "%decimal2%"=="." && set decimal2= && set numdeci2=0 ! set decimal2=%decimal2:~1%
if not %decimal2:~-1,1%==k if not %decimal2:~-1,1%==m if not %decimal2:~-1,1%==g |; set decimal2=%decimal2:~0,-1% && set d2kmg=%decimal2:~-1,1% &; if exist N2kmg && set "message=Operation '%function%' not allowed, check second number '%~2'" && goto :eof
if exist decimal2 &; if %decimal2:~-1,1%==e && set decimal2=%decimal2:~0,-1% && set d2epi=2.718281828459045235 ! if %decimal2:~-2,2%==pi && set decimal2=%decimal2:~0,-2% && set d2epi=3.141592653589793238 &; if exist epi2 && set "message=Operation '%function%' not allowed, check first number '%~1'" && goto :eof
if exist decimal2 && call Fn.11 "%decimal2%" "+" && set "message=Abort '%function%': bad input, check '%~2'" && goto :eof
if exist decimal2 && call Fn.11 "%decimal2%" "-" && set "message=Abort '%function%': bad input, check '%~2'" && goto :eof
if exist decimal2 &; if %decimal2%==0 && set decimal2= && set numdeci2=0 ! call Fn.11 "%decimal2%" "G" && set "message=Abort '%function%': bad input in '%~2'" && goto :eof ! call Fn.11 "%decimal2%" "g" && set "message=Abort '%function%': bad input in '%~2'" && goto :eof ! call Fn.11 "%decimal2%" "M" && set "message=Abort '%function%': bad input in '%~2'" && goto :eof ! call Fn.11 "%decimal2%" "m" && set "message=Abort '%function%': bad input in '%~2'" && goto :eof ! call Fn.11 "%decimal2%" "K" && set "message=Abort '%function%': bad input in '%~2'" && goto :eof ! call Fn.11 "%decimal2%" "k" && set "message=Abort '%function%': bad input in '%~2'" && goto :eof
if exist decimal2 && set decimal2=%decimal2:~0,18% &; set /a numdeci2=%@retval% && if %decimal2:~-1,1%==0 && if not exist fix && call :stripzerosafter "%decimal2%" &; set decimal2=%result% && set result= &; if exist decimal2 && set decimal2=%decimal2% &; set /a numdeci2=%@retval%
if not exist decimal2 && set numdeci2=0
if exist d2epi &; setlocal && set epi=%d2epi% && set d2epi= &; call :* * "%N2%.%decimal2%" "%epi%" &; call :splitnumber "%result%" &; if exist message && endlocal && set "message=%message%" && goto :eof ! endlocal && set N2=%N% && set decimal2=%decimals% && set numdeci2=%numdecis% && set d2epi=%d2epi%
if exist d2kmg &; setlocal && set kmg=%d2kmg% && set d2kmg= &; call :* * "%N2%.%decimal2%" "1%kmg%" &; call :splitnumber "%result%" &; if exist message && endlocal && set "message=%message%" && goto :eof ! endlocal && set N2=%N% && set decimal2=%decimals% && set numdeci2=%numdecis% && set d2kmg=%d2kmg%
set epi2= && goto :eof
::
:endlocal
endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && set fixed=%fixed%
goto :eof
::
:lastinput
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
shift
set n1=%~1 &; if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R% ! if /i %n1:~-3,3%==mr! && set n1=%n1:~0,-3%%%MR%! && set lastrnd=
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
call :operatorsinput %0 "%n1%" &; if exist message && goto :endlocal
if %sign1%==-1 && set sign=-
if exist decimal1 && set result=%sign%%%N1%.%decimal1% ! set result=%sign%%%N1%
goto :endlocal
::
:+
#-#+ + \tOperator + : Decimal summation of number1 and number2
#-# Use\tCALCD2.G4B [switch] number1 + number2\nRemarks Infix operator, existing result can be used instead of number1\n\tOutput: max 19 integers + 18 decimals, no rounding\nExample\tCALCD.G4B 2.2 + 3\nExample\tCALCD.G4B 2.2568 + 700.123\nExample\tCALCD.G4B -20.56 + -9.7\nExample\tCALCD.G4B -20.56 + -9.7 + R\nExample\tCALCD.G4B +45.89 + 200000.7\nExample\tCALCD.G4B +45.89 + 200000.7 MS STDEVP 2 7 MP MR\nExample\tCALCD.G4B 45.89+200,000.7MS45.89*200,000.7MPMRTHSEP\nExample CALCD.G4B 1 + 1\x20;;\x20CALCD.G4B R + 1\x20;;\x20CALCD.G4B + 1\x20;;\x20echo\x20&&\x20set\nExample CALCD.G4B 10\nExample CALCD.G4B 10.10\nExample CALCD.G4B 3,628,800.0000000\nExample CALCD.G4B 10!\nExample set fix=5 ;; CALCD.G4B 3,628,800.0000000\nExample set * ;; CALCD.G4B 0x7FFFFFFFFFFFFFFF\nExample set * ;; CALCD.G4B --Q 0x7FFFFFFFFFFFFFFF ;; echo && set\nExample CALCD.G4B 0x8000000000000000\nExample set * ;; CALCD.G4B --Q 0x8000000000000000 ;; set r ;; set
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~3"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
shift
set n1=%~1 &; if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
set n2=%~2 &; if /i %n2:~-2,2%==mr && set n2=%n2:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n2%==r && set n2=%R% ! if /i %n2%==-r && set n2=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
if /i "%n2:~-1,1%"=="!" && set n2=%n2:~0,-1% &; if %n2:~0,1%==- && set n2=%n2:~1% && set sign=- ! set sign= &; call :fact goback %n2% &; if exist result && set n2=%sign%%%result% && set result= ! set rounded= && goto :endlocal
call :operatorsinput %0 "%n1%" "%n2%" &; if exist message && goto :endlocal
if exist decimal1 && if not exist decimal2 && set decimal2=0 && set numdeci2=1
if exist decimal2 && if not exist decimal1 && set decimal1=0 && set numdeci1=1
if not %numdeci1%>=%numdeci2% && call :addzerosafter "%numdeci1%" "%numdeci2%" "%decimal1%" &; set decimal1=%result% &; set /a numdeci1=%@retval% && set result=
if not %numdeci2%>=%numdeci1% && call :addzerosafter "%numdeci2%" "%numdeci1%" "%decimal2%" &; set decimal2=%result% &; set /a numdeci2=%@retval% && set result=
set numdeci=%numdeci1%
set integer1=%N1% &; set /a intlen1=%@retval%
set integer2=%N2% &; set /a intlen2=%@retval%
if not %intlen1%<=18 &; if %intlen1%==19 && if %intlen1:~0,1%==9 && if not %intlen1:~1%<=223372036854775806 && set "message=Substraction out of range, check first number '%~1'" && goto :eof ! if not %intlen1%<=19 && set "message=Addition out of range, check first number '%~1'" && goto :endlocal
if not %intlen2%<=18 &; if %intlen2%==19 && if %intlen2:~0,1%==9 && if not %intlen2:~1%<=223372036854775806 && set "message=Substraction out of range, check second number '%~2'" && goto :eof ! if not %intlen2%<=19 && set "message=Addition out of range, check second number '%~2'" && goto :endlocal
if not %intlen1%>=%intlen2% && set /a maxlen=%intlen2% ! set /a maxlen=%intlen1%
if not %maxlen%<=18 && if %sign1%==1 && if %sign2%==1 && if not integer1==0 && if not integer2==0 && set /a integer=%integer1%+%integer2% &; if %integer%<=0 && set "message=Addition out of range, check '%~1' or '%~2'" && goto :endlocal
if not %maxlen%<=18 && if %sign1%==-1 && if %sign2%==-1 && if not integer1==0 && if not integer2==0 && set /a integer=%integer1%+%integer2% &; if %integer%<=0 && set "message=Addition out of range, check '%~1' or '%~2'" && goto :endlocal
if %numdeci%==0 && set /a result=%sign1:~0,-1%%%N1% + %sign2:~0,-1%%%N2% && goto :endlocal
set /a integer=%sign1:~0,-1%%%N1% + %sign2:~0,-1%%%N2% && set N1= && set N2= &; if "%integer:~0,1%"=="-" && set signint=- && set integer=%integer:~1%
set /a decimals=%sign1:~0,-1%%%decimal1% + %sign2:~0,-1%%%decimal2% &; if "%decimals:~0,1%"=="-" && set signdec1=- && set decimals=%decimals:~1%
set decimals=000000000000000000%decimals% &; call set /a N1=%^decimals:~0,-%numdeci%%% && call set decimals=%^decimals:~-%numdeci%,%numdeci%%%
if not %integer%==0 && if not "%signint%"=="%signdec1%" && set UNO=000000000000000000 &; call set UNO=1%^UNO:~0,%numdeci%%%
if not %integer%==0 && if not "%signint%"=="%signdec1%" && set /a decimals=%signint%%%UNO% + %signdec1%%%decimals% &; if "%decimals:~0,1%"=="-" && set signdec2=- && set decimals=%decimals:~1%
if not %integer%==0 && if not "%signint%"=="%signdec1%" && set decimals=000000000000000000%decimals% &; call set /a N2=%^decimals:~0,-%numdeci%%% && call set decimals=%^decimals:~-%numdeci%,%numdeci%%%
if %integer%==0 && set integer=%signdec1%%%N1% ! if "%signint%"=="%signdec1%" && set /a integer=%signint%%%integer% + %signdec1%%%N1% ! if "%signdec1%"=="-" && set /a integer=%signint%%%integer% - 1 ! if "%signdec2%"=="-" && set /a integer=%signint%%%integer% + 1
if %decimals%==0 && set /a result=%integer% && goto :endlocal
if %integer%==0 && if "%signdec2%"=="-" && set integer=-0
set result=%integer%.%decimals%
goto :endlocal
::
:-
#-#+ - \tOperator - : Decimal substraction of number1 and number2
#-# Use\tCALCD.G4B [switch] number1 - number2\nRemarks\tInfix operator, existing result can be used instead of number1\n\tOutput: max 19 integers + 18 decimals, no rounding\nExample CALCD.G4B 5.2 - 3\nExample CALCD.G4B 2.2568 - -700.123\nExample CALCD.G4B -67.56 - 59.7\nExample CALCD.G4B 200000.7 - +45.349\nExample CALCD.G4B --echo 200000.7-45.349MS11INV*1,000MNMRROUND2THSEP\nExample CALCD.G4B 1 - 1\x20;;\x20CALCD.G4B R - 1\x20;;\x20CALCD.G4B - 1\x20;;\x20echo\x20&&\x20set
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~3"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
shift
set n1=%~1 &; if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
set n2=%~2 &; if /i %n2:~-2,2%==mr && set n2=%n2:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n2%==r && set n2=%R% ! if /i %n2%==-r && set n2=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
if /i "%n2:~-1,1%"=="!" && set n2=%n2:~0,-1% &; if %n2:~0,1%==- && set n2=%n2:~1% && set sign=- ! set sign= &; call :fact goback %n2% &; if exist result && set n2=%sign%%%result% && set result= ! set rounded= && goto :endlocal
call :operatorsinput %0 "%n1%" "%n2%" &; if exist message && goto :endlocal
if exist decimal1 && if not exist decimal2 && set decimal2=0 && set numdeci2=1
if exist decimal2 && if not exist decimal1 && set decimal1=0 && set numdeci1=1
if not %numdeci1%>=%numdeci2% && call :addzerosafter "%numdeci1%" "%numdeci2%" "%decimal1%" &; set decimal1=%result% &; set /a numdeci1=%@retval% && set result=
if not %numdeci2%>=%numdeci1% && call :addzerosafter "%numdeci2%" "%numdeci1%" "%decimal2%" &; set decimal2=%result% &; set /a numdeci2=%@retval% && set result=
set numdeci=%numdeci1%
set integer1=%N1% &; set /a intlen1=%@retval%
set integer2=%N2% &; set /a intlen2=%@retval%
if not %intlen1%<=18 &; if %intlen1%==19 && if %intlen1:~0,1%==9 && if not %intlen1:~1%<=223372036854775807 && set "message=Substraction out of range, check first number '%~1'" && goto :eof ! if not %intlen1%<=19 && set "message=Substraction out of range, check first number '%~1'" && goto :endlocal
if not %intlen2%<=18 &; if %intlen2%==19 && if %intlen2:~0,1%==9 && if not %intlen2:~1%<=223372036854775807 && set "message=Substraction out of range, check second number '%~2'" && goto :eof ! if not %intlen2%<=19 && set "message=Substraction out of range, check second number '%~2'" && goto :endlocal
if not %intlen1%>=%intlen2% && set /a maxlen=%intlen2% ! set /a maxlen=%intlen1%
if not %maxlen%<=18 && if %sign1%==1 && if %sign2%==-1 && if not integer1==0 && if not integer2==0 && set /a integer=%integer1%-%integer2% &; if %integer%<=0 && set "message=Substraction out of range, check '%~1' or '%~2'" && goto :endlocal
if not %maxlen%<=18 && if %sign1%==-1 && if %sign2%==1 && if not integer1==0 && if not integer2==0 && set /a integer=%integer1%-%integer2% &; if %integer%<=0 && set "message=Substraction out of range, check '%~1' or '%~2'" && goto :endlocal
if %numdeci%==0 && set /a result=%sign1:~0,-1%%%N1% - %sign2:~0,-1%%%N2% && goto :endlocal
set /a integer=%sign1:~0,-1%%%N1% - %sign2:~0,-1%%%N2% && set N1= && set N2= &; if "%integer:~0,1%"=="-" && set signint=- && set integer=%integer:~1%
set /a decimals=%sign1:~0,-1%%%decimal1% - %sign2:~0,-1%%%decimal2% &; if "%decimals:~0,1%"=="-" && set signdec1=- && set decimals=%decimals:~1%
set decimals=000000000000000000%decimals% &; call set /a N1=%^decimals:~0,-%numdeci%%% && call set decimals=%^decimals:~-%numdeci%,%numdeci%%%
if not %integer%==0 && if not "%signint%"=="%signdec1%" && set UNO=000000000000000000 &; call set UNO=1%^UNO:~0,%numdeci%%%
if not %integer%==0 && if not "%signint%"=="%signdec1%" && set /a decimals=%signint%%%UNO% + %signdec1%%%decimals% &; if "%decimals:~0,1%"=="-" && set signdec2=- && set decimals=%decimals:~1%
if not %integer%==0 && if not "%signint%"=="%signdec1%" && set decimals=000000000000000000%decimals% &; call set /a N2=%^decimals:~0,-%numdeci%%% && call set decimals=%^decimals:~-%numdeci%,%numdeci%%%
if %integer%==0 && set integer=%signdec1%%%N1% ! if "%signint%"=="%signdec1%" && set /a integer=%signint%%%integer% + %signdec1%%%N1% ! if "%signdec1%"=="-" && set /a integer=%signint%%%integer% - 1 ! if "%signdec2%"=="-" && set /a integer=%signint%%%integer% + 1
if %decimals%==0 && set /a result=%integer% && goto :endlocal
if %integer%==0 && if "%signdec2%"=="-" && set integer=-0
set result=%integer%.%decimals%
goto :endlocal
::
:*
#-#+ * \tOperator * : Decimal multiplication of number1 and number2
#-# Use\tCALCD.G4B [switch] number1 * number2\nRemarks\tInfix operator, existing result can be used instead of number1\n\tInternally 55 digits, 19th decimal is used for rounding\nExample CALCD.G4B 2.2 * 3\nExample CALCD.G4B 2.2568 * 700.123\nExample CALCD.G4B -0.56 * -59.7\nExample CALCD.G4B 0.0123456789 * 200000.7\nExample CALCD.G4B -.0123456789 * +200000.7\nExample CALCD.G4B --echo -.0123456789*-200000.7MS*80MPSRM\nExample CALCD.G4B 100,000 * 1 / 3\nExample CALCD.G4B 3 INV * 100,000
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~3"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
shift
set n1=%~1 &; if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
set n2=%~2 &; if /i %n2:~-2,2%==mr && set n2=%n2:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n2%==r && set n2=%R% ! if /i %n2%==-r && set n2=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
if /i "%n2:~-1,1%"=="!" && set n2=%n2:~0,-1% &; if %n2:~0,1%==- && set n2=%n2:~1% && set sign=- ! set sign= &; call :fact goback %n2% &; if exist result && set n2=%sign%%%result% && set result= ! set rounded= && goto :endlocal
call :operatorsinput %0 "%n1%" "%n2%" &; if exist message && goto :endlocal
set sign=- &; if not "%sign1%"=="-1" && if not "%sign2%"=="-1" && set sign= ! if "%sign1%"=="-1" && if "%sign2%"=="-1" && set sign=
if %numdeci1%==0 && if %numdeci2%==0 && set /a N=%N1% * %N2% &; if not %N1%==0 && if not %N2%==0 && if %N%<=0 && set "message=Multiplication out of range, check '%~1' or '%~2'" && goto :endlocal ! set result=%sign%%%N% && goto :endlocal
set /a numdeciP=%numdeci1% + %numdeci2%
set N1=000000000000000000%N1% && set N2=000000000000000000%N2%
set d1=%decimal1%%000000000000000000000000000000000000 && set decimal1= && set numdeci1=
set d2=%decimal2%%000000000000000000000000000000000000 && set decimal2= && set numdeci2=
set /a N1B=%N1:~-19,10% && set /a N1A=%N1:~-9,9%
set /a N2B=%N2:~-19,10% && set /a N2A=%N2:~-9,9%
set d1A=%d1:~0,9% && set d1B=%d1:~9,9% && set d1C=%d1:~18,9%
set d2A=%d2:~0,9% && set d2B=%d2:~9,9% && set d2C=%d2:~18,9%
setlocal
set /a d1Ad2C=%d1A% * %d2C%
set /a d2Ad1C=%d2A% * %d1C%
set /a d1Bd2B=%d1B% * %d2B%
set /a SumEm36=%d1Ad2C% + %d2Ad1C% + %d1Bd2B%
set d1d2m36=%SumEm36:~-9,9% && set /a SEm36p9=%SumEm36:~0,-9%
set d1d2m36=000000000%d1d2m36%
set d1d2m36=%d1d2m36:~-9,9%
endlocal && set d1d2m36= && set SEm36p9=%SEm36p9%
setlocal
set /a N1Ad2C=%N1A% * %d2C%
set /a N2Ad1C=%N2A% * %d1C%
set /a d1Ad2B=%d1A% * %d2B%
set /a d2Ad1B=%d2A% * %d1B%
set /a SumEm27=%N1Ad2C% + %N2Ad1C% + %d1Ad2B% + %d2Ad1B% + %SEm36p9%
set d1d2m27=%SumEm27:~-9,9% && set /a SEm27p9=%SumEm27:~0,-9%
set d1d2m27=000000000%d1d2m27%
set d1d2m27=%d1d2m27:~-9,9%
if %d1d2m27:~-9,1%>=5 && set /a SEm27p9=%SEm27p9% + 1 && set lastrnd=1 ! set lastrnd=0
endlocal && set d1d2m27= && set SEm27p9=%SEm27p9% && set lastrnd=%lastrnd%
setlocal
set /a N1Bd2C=%N1B% * %d2C%
set /a N2Bd1C=%N2B% * %d1C%
set /a N1Ad2B=%N1A% * %d2B%
set /a N2Ad1B=%N2A% * %d1B%
set /a d1Ad2A=%d1A% * %d2A%
set /a SumEm18=%N1Bd2C% + %N2Bd1C% + %N1Ad2B% + %N2Ad1B% + %d1Ad2A% + %SEm27p9%
set d1d2m18=%SumEm18:~-9,9% && set /a SEm18p9=%SumEm18:~0,-9%
set d1d2m18=000000000%d1d2m18%
set d1d2m18=%d1d2m18:~-9,9%
endlocal && set d1d2m18=%d1d2m18% && set SEm18p9=%SEm18p9%
setlocal
set /a N1Bd2B=%N1B% * %d2B%
set /a N2Bd1B=%N2B% * %d1B%
set /a N1Ad2A=%N1A% * %d2A%
set /a N2Ad1A=%N2A% * %d1A%
set /a SumEm9=%N1Bd2B% + %N2Bd1B% + %N1Ad2A% + %N2Ad1A% + %SEm18p9%
set d1d2m9=%SumEm9:~-9,9% && set /a SEm9p9=%SumEm9:~0,-9%
set d1d2m9=000000000%d1d2m9%
set d1d2m9=%d1d2m9:~-9,9%
endlocal && set d1d2m9=%d1d2m9% && set SEm9p9=%SEm9p9%
setlocal
set /a N1Bd2A=%N1B% * %d2A%
set /a N2Bd1A=%N2B% * %d1A%
set /a N1AN2A=%N1A% * %N2A%
set /a SumEp0=%N1Bd2A% + %N2Bd1A% + %N1AN2A% + %SEm9p9%
set SumEp0=0000000000%SumEp0%
set N1N2p0=%SumEp0:~-9,9% && set /a SE0p9=%SumEp0:~0,-9%
set N1N2p0=000000000%N1N2p0%
set N1N2p0=%N1N2p0:~-9,9%
endlocal && set N1N2p0=%N1N2p0% && set SE0p9=%SE0p9%
setlocal
set /a N1BN2A=%N1B% * %N2A%
set /a N2BN1A=%N2B% * %N1A%
set /a SumEp9=%N1BN2A% + %N2BN1A% + %SE0p9%
set SumEp9=0000000000%SumEp9%
set N1N2p9=%SumEp9:~-10,10%
if %N1N2p9%==0 && set N1N2p9=
endlocal && set N1N2p9=%N1N2p9%
#NOTNEEDEDNOW#Above 10exp18
##setlocal
##set /a N1CN2A=%N1C% * %N2A%
##set /a N2CN1A=%N2C% * %N1A%
##set /a SumEp18=%N1CN2A% + %N2CN1A% + %SE9p9%
##set SumEp18=0000000000%SumEp18%
##set N1N2p18=%SumEp18:~-10,10%
##if %N1N2p18%==0 && set N1N2p18=
##endlocal && set N1N2p18=%N1N2p18%
if %d1d2m36%==0 && set d1d2m36=
if not exist d1d2m36 && if %d1d2m27%==0 && set d1d2m27=
if not exist d1d2m27 && if %d1d2m18%==0 && set d1d2m18=
if not %d1d2m9%%%d1d2m18%==0 && set resdec=%d1d2m9%%%d1d2m18% ! set resdec=
if not exist N1N2p9 && set /a N1N2p0=%N1N2p0%
set resint=%N1N2p9%%%N1N2p0%
if exist resdec && if not %rounded%==Y && call :stripzerosafter "%resdec%" &; set resdec=%result% && set result=
if %resint%>=1 && call :stripzerosbefore "%resint%" &; set resint=%result% && set result=
if exist resdec && set result=%sign%%%resint%.%resdec% ! set result=%sign%%%resint%
goto :endlocal
::
:/
#-#+ / \tOperator / : Decimal Decimal division of number1 and number2
#-# Use\tCALCD.G4B [switch] number1 / number2\nRemarks\tInfix operator, existing result can be used instead of number1\n\tInternally 56 digits, 19th decimal is used for rounding\n\tHighest divisor: 922,337,203,685,477,580 or 0xCCCCCCCCCCCCCCC\nExample CALCD.G4B 20 / 3.3333\nExample CALCD.G4B 1111111111111111111.111111111111111111 / 87654321.123456789\nExample CALCD.G4B 100,000.1234 / -2.5 THSEP\nExample CALCD.G4B +2050.234 / -7 FIX 4\nExample CALCD.G4B 1 / 0.0001\nExample CALCD.G4B 0.0001/0.0001MS0.0001/0.0001MNMR\nExample CALCD.G4B 1 / 3 * 100,000\nExample CALCD.G4B 100,000 * 1 / 3\nExample CALCD.G4B 1:4 / 2:3\nExample CALCD.G4B 1'1:9/3'1:18\nExample CALCD.G4B 1:9pi/1:18e
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~3"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
shift
set n1=%~1 &; if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
set n2=%~2 &; if /i %n2:~-2,2%==mr && set n2=%n2:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n2%==r && set n2=%R% ! if /i %n2%==-r && set n2=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
if /i "%n2:~-1,1%"=="!" && set n2=%n2:~0,-1% &; if %n2:~0,1%==- && set n2=%n2:~1% && set sign=- ! set sign= &; call :fact goback %n2% &; if exist result && set n2=%sign%%%result% && set result= ! set rounded= && goto :endlocal
call :operatorsinput %0 "%n1%" "%n2%" &; if exist message && goto :endlocal
if not exist decimal1 && if %N1%==0 &; if not %N2%==0 && set result=0 && goto :endlocal ! if exist decimal2 && set result=0 && goto :endlocal
if %N1%==0 && set factord1=0 && set factord2=0 && if %decimal1:~0,1%==0 && set factor=0 &; if %decimal1:~0,17%==0 && set factor=17 ! if %decimal1:~0,16%==0 && set factor=16 ! if %decimal1:~0,15%==0 && set factor=15 ! if %decimal1:~0,14%==0 && set factor=14 ! if %decimal1:~0,13%==0 && set factor=13 ! if %decimal1:~0,12%==0 && set factor=12 ! if %decimal1:~0,11%==0 && set factor=11 ! if %decimal1:~0,10%==0 && set factor=10 ! if %decimal1:~0,9%==0 && set factor=9 ! if %decimal1:~0,8%==0 && set factor=8 ! if %decimal1:~0,7%==0 && set factor=7 ! if %decimal1:~0,6%==0 && set factor=6 ! if %decimal1:~0,5%==0 && set factor=5 ! if %decimal1:~0,4%==0 && set factor=4 ! if %decimal1:~0,3%==0 && set factor=3 ! if %decimal1:~0,2%==0 && set factor=2 ! set factor=1 &; call set decimal1=%^decimal1:~%factor%%% &; set /a numdeci1=%@retval% && set factord1=%factor% && set factor=
if %N2%==0 && set factord2=0 && if %decimal2:~0,1%==0 && set factor=0 &; if %decimal2:~0,17%==0 && set factor=17 ! if %decimal2:~0,16%==0 && set factor=16 ! if %decimal2:~0,15%==0 && set factor=15 ! if %decimal2:~0,14%==0 && set factor=14 ! if %decimal2:~0,13%==0 && set factor=13 ! if %decimal2:~0,12%==0 && set factor=12 ! if %decimal2:~0,11%==0 && set factor=11 ! if %decimal2:~0,10%==0 && set factor=10 ! if %decimal2:~0,9%==0 && set factor=9 ! if %decimal2:~0,8%==0 && set factor=8 ! if %decimal2:~0,7%==0 && set factor=7 ! if %decimal2:~0,6%==0 && set factor=6 ! if %decimal2:~0,5%==0 && set factor=5 ! if %decimal2:~0,4%==0 && set factor=4 ! if %decimal2:~0,3%==0 && set factor=3 ! if %decimal2:~0,2%==0 && set factor=2 ! set factor=1 &; call set decimal2=%^decimal2:~%factor%%% &; set /a numdeci2=%@retval% && set factord2=%factor% && set factor= && if not exist factord1 && set factord1=0
if not %N1%==0 if not %N2%==0 |; set /a factor=%factord2%-%factord1% &; if %factor%==0 && set factor=
if %N2%>=1 && set integer2=%N2%%%decimal2% &; set /a int2len=%@retval%
if %N2%==0 && set /a integer2=%decimal2% &; set /a int2len=%@retval% &; if not %int2len%<=18 && set integer2=%integer2:~0,18% && set /a numdeci2=18 &; if %numdeci2%>=1 && call set decimal2=%^decimal2:~0,%numdeci2%%% ! set decimal2= && set numdeci2=0
if %N1%>=1 && set integer1=%N1%%%decimal1% &; set /a int1len=%@retval%
if %N1%==0 && set /a integer1=%decimal1% &; set /a int1len=%@retval% &; if not %int1len%<=18 && set integer1=%integer1:~0,18% && set /a numdeci1=18 &; if %numdeci1%>=1 && call set decimal1=%^decimal1:~0,%numdeci1%%% ! set decimal1= && set numdeci1=0
if %N2%==0 && if %decimal2%==0 && set "message=Abort %0: divisor '%~2' is zero" && goto :endlocal
if %N2%==0 && if not exist decimal2 && set "message=Abort %0: divisor '%~2' is (near) zero" && goto :endlocal
if %N1%>=1 && set /a N1=%N1% &; set number1=%N1%%%decimal1% &; set /a num1len=%@retval%
if %N1%==0 && set number1=%decimal1% &; set /a num1len=%@retval%
if %N2%>=1 && set /a N2=%N2% &; set number2=%N2%%%decimal2% &; set /a num2len=%@retval%
if %N2%==0 && set number2=%decimal2% &; set /a num2len=%@retval%
if %factor%>=1 && if %N1%>=1 && set /a divilen=%N1len%+%factor% &; if %divilen%>=19 && set "message=Division out of range" && goto :endlocal ! set divilen=
if not %N2%<=922337203685477580 && set "message=Division out of range" && goto :endlocal
set /a decidiff=%numdeci1% - %numdeci2%
if %N1%==0 && if %decimal1:~0,1%==0 && goto :longerdivider ! if %N2%==0 && if %decimal2:~0,1%==0 && goto :longerdivider
if not %num2len%<=10 && goto :longdivider
if not %number2%<=0xCCCCCCC && goto :longdivider
set num2loop=0
:calcnum2loop
if %num1len%<=19 && if not %number2%<=%number1% && set number1=%number1%%0 && set /a num2loop=%num2loop% + 1 && goto :calcnum2loop
set number2=%number2% &; set /a num2len=%@retval%
set divloops=0
set /a maxloops=19 - %decidiff% - %num2loop%
if %num1len%<=10 &; if not %number1%>=0x80000000 && goto :calcremainloop
set num1div=%number1%
set div1len=%num2len%
:calcdividendloop
set num1div=%num1div% &; set /a num1len=%@retval%
if %num2len%<=%num1len% &; call if %number2%<=%^num1div:~0,%div1len%%% && call set dividend=%^num1div:~0,%div1len%%% && call set num1div=%^num1div:~%div1len%%% ! set /a div1len=%div1len% + 1 && goto :calcdividendloop
:calcdivideloop
if %dividend%>=0x80000000 && set "message=Division out of range" && goto :endlocal
set /a result=%dividend% / %number2% &; set sum=%sum%%%result% && set /a remainer=%dividend% % %number2%
if exist num1div && set dividend=%remainer%%%num1div:~0,1% && set num1div=%num1div:~1% && goto :calcdivideloop
if not %remainer%==0 && if not %divloops%>=%maxloops% && set dividend=%remainer%%0 && set /a divloops=%divloops% + 1 && goto :calcdivideloop
set /a numdeci=%divloops% + %num2loop% + %decidiff%
set sum=0000000000000000000%sum% && set result=
goto :calcdivideend
:calcremainloop
if %number1%>=0x80000000 && set "message=Division out of range" && goto :endlocal
set /a result=%number1% / %number2%
set /a remainer=%number1% % %number2%
set sum=%sum%%%result% && if not %remainer%==0 && if not %divloops%>=%maxloops% && set number1=%remainer%%0 && set /a divloops=%divloops% + 1 && goto :calcremainloop
set /a numdeci=%divloops% + %num2loop% + %decidiff%
set sum=0000000000000000000%sum% && set result=
:calcdivideend
if %numdeci%>=1 && call set /a integer=%^sum:~0,-%numdeci%%% && call set decimals=%^sum:~-%numdeci%,%numdeci%%% ! if %numdeci%==0 && set /a integer=%sum%
if exist round2 && if %numdeci%>=1 && set decidiff=0 && set integer=%integer% &; set /a intlen=%@retval% && if %integer%==0 && set intlen=0
if exist round2 && if %intlen%==0 && if %numdeci%>=2 && call :stripzerosbefore "%decimals%" &; set result=%result% &; set /a decidiff=%numdeci% - %@retval% && set result=
if exist round2 && if %numdeci%>=1 &; if %integer%>=1 && set sum=%integer%%%decimals% ! set sum=%decimals% && set /a num2len=%num2len% + %decidiff%
if exist round2 && call set sum=%^sum:~0,%num2len%%% &; set /a numdeci=%num2len% - %intlen%
if exist round2 && if %numdeci%>=1 && set sum=0000000000000000000%sum%
if exist round2 &; if %numdeci%>=1 && set round2= && goto :calcdivideend ! set decimals=
if not %numdeci%>=0 && set zeros=0000000000000000000 && set /a numzeros=-1 * %numdeci% &; call set zeros=%^zeros:~0,%numzeros%%% &; set /a integer=%sum%%%zeros%
set maxdeci=19 &; if %numdeci%>=%maxdeci% && set numdeciO=%numdeci% && set /a numdeci=%maxdeci% - 1 &; call set decimals=%^decimals:~0,%maxdeci%%% &; if not %decimals:~-1,1%==0 && set rounded=Y
if exist numdeciO && if not %numdeci%>=%numdeciO% &; if %decimals:~-1,1%>=5 && set /a decimal=%decimals:~0,-1% + 1 && set lastrnd=1 ! set /a decimal=%decimals:~0,-1% && set lastrnd=0 &; set decimal=000000000000000000%decimal% &; call set decimals=%^decimal:~-%numdeci%,%numdeci%%% && call set /a round=%^decimal:~0,-%numdeci%%% &; if %round%>=1 && set /a integer=%integer% + %round%
if not %remainer%==0 && set rounded=Y
if exist decimals && set quotient=%integer%.%decimals% ! set quotient=%integer%
if exist factor &; if %factor%>=1 && set multiply=000000000000000000 &; call set multiply=1%^multiply:~0,%factor%%% &; call :* * "%quotient%" "%multiply%" &; if exist result && set quotient=%result% && set result= ! goto :endlocal
if exist factor &; if %factor%<=-1 && set multiply=00000000000000000 && set /a factor=-1 * %factor% - 1 &; call set multiply=0.%^multiply:~0,%factor%%%%1 &; call :* * "%quotient%" "%multiply%" &; if exist result && set quotient=%result% && set result= ! goto :endlocal
set sign=- &; if not "%sign1%"=="-1" && if not "%sign2%"=="-1" && set sign= ! if "%sign1%"=="-1" && if "%sign2%"=="-1" && set sign=
set result=%sign%%%quotient%
goto :endlocal
::
:longdivider
if not %num2len%<=18 && goto :longerdivider
if not %number2%<=0xCCCCCCCCCCCCCC && goto :longerdivider
set number2=%number2% &; set /a num2len=%@retval%
set /a maxloops=19 - %decidiff%
set zeroloop=0
call set dividend=%^number1:~0,%num2len%%% && call set number1=%^number1:~%num2len%%%
:calclongdividendloop
if not exist number1 && if not %end%==Y && set number1=0000000000000000000000000000000000000000 && set end=Y
if not %dividend%>=%number2% && set dividend=%dividend%%%number1:~0,1% && set number1=%number1:~1% && set sum=%sum%%0 &; if %end%==Y && set /a zeroloop=%zeroloop% + 1
if not %dividend%>=%number2% && goto :calclongdividendloop
set D=1
:calclongdividerloop
if not exist number1 && if not %end%==Y && set number1=0000000000000000000000000000000000000000 && set end=Y
set /a remainer=%dividend% - %number2%
if %remainer%>=%number2% && set dividend=%remainer% && set /a D=%D% + 1 && goto :calclongdividerloop
if %remainer%>=0 && set sum=%sum%%%D% && set D=1 && if exist number1 && set dividend=%remainer%%%number1:~0,1% && set number1=%number1:~1%
if not %remainer%>=0 && set sum=%sum%%0 && set D=1 && if exist number1 && set dividend=%dividend%%%number1:~0,1% && set number1=%number1:~1%
if exist dividend && if not %zeroloop%>=%maxloops% &; if %end%==Y && set /a zeroloop=%zeroloop% + 1 && goto :calclongdividerloop ! goto :calclongdividerloop
set lostlen=0 && if exist num2lost && set num2lost=%num2lost% &; set /a lostlen=%@retval%
set /a numdeci=%zeroloop% + %decidiff% + %lostlen%
set sum=0000000000000000000%sum%
if %numdeci%>=1 && call set /a integer=%^sum:~0,-%numdeci%%% && call set decimals=%^sum:~-%numdeci%,%numdeci%%% ! if %numdeci%==0 && set /a integer=%sum%
set maxdeci=19
if %numdeci%>=%maxdeci% && set numdeciO=%numdeci% && set /a numdeci=%maxdeci% - 1 &; call set decimals=%^decimals:~0,%maxdeci%%% &; if not %decimals:~-1,1%==0 && set rounded=Y
if exist numdeciO && if not %numdeci%>=%numdeciO% &; if %decimals:~-1,1%>=5 && set /a decimal=%decimals:~0,-1% + 1 && set lastrnd=1 ! set decimal=%decimals:~0,-1% && set lastrnd=0 &; set decimal=000000000000000000%decimal% &; call set decimals=%^decimal:~-%numdeci%,%numdeci%%% && call set round=%^decimal:~0,-%numdeci%%% &; if %round%>=1 && set /a integer=%integer% + %round%
if %remainer%==-%number2% && set remainer=0
if not %remainer%==0 && set rounded=Y
if exist decimals && set quotient=%integer%.%decimals% ! set quotient=%integer%
if exist factor &; if %factor%>=1 && set multiply=000000000000000000 &; call set multiply=1%^multiply:~0,%factor%%% &; call :* * "%quotient%" "%multiply%" &; if exist result && set quotient=%result% && set result= ! goto :endlocal
if exist factor &; if %factor%<=-1 && set multiply=00000000000000000 && set /a factor=-1 * %factor% - 1 &; call set multiply=0.%^multiply:~0,%factor%%%%1 &; call :* * "%quotient%" "%multiply%" &; if exist result && set quotient=%result% && set result= ! goto :endlocal
set sign=- &; if not "%sign1%"=="-1" && if not "%sign2%"=="-1" && set sign= ! if "%sign1%"=="-1" && if "%sign2%"=="-1" && set sign=
set result=%sign%%%quotient%
goto :endlocal
::
:longerdivider
if exist decimal1 && set number1=%N1%.%decimal1% ! set number1=%N1%
if exist decimal2 && set number2=%N2%.%decimal2% ! set number2=%N2%
set N1=%N1% &; set /a N1len=%@retval% && if %N1%==0 && set N1len=0
set N2=%N2% &; set /a N2len=%@retval% && if %N2%==0 && set N2len=0
set numdeci=0
if %N1%==0 && if %numdeci1%>=1 && set /a decimalA=%decimal1% &; set /a numdeciA=%@retval% &; set /a numdeci=%numdeci% + %numdeci1% - %numdeciA% && set decimal1=%decimalA%
if %N2%==0 && if %numdeci2%>=1 && set /a decimalB=%decimal2% &; set /a numdeciB=%@retval% &; set /a numdeci=%numdeci% - %numdeci2% + %numdeciB% && set decimal2=%decimalB%
if not %numdeci%>=0 && set numdeci0=%numdeci% ! set numdeci0=0
if %N1%>=1 && set N1=%N1% &; set /a N1len=%@retval%
if exist N1 &; if %N1len%>=2 && set /a factor1=%N1len% - 1 ! set factor1=0
if not %N1len%<=%N2len% && set /a N=%N1:~0,1% && set N1=%N1:~1%
if %N1len%<=%N2len% && set N=%N1% && set N1= && set factor1=0 && set decimals=%decimal1% && set decimal1=
:longerdividendloop
if not %N%>=%N2% &; if exist N1 && set /a N=%N%%%N1:~0,1% && set N1=%N1:~1% ! if exist decimal1 && set /a N=%N%%%decimal1:~0,1% && set decimal1=%decimal1:~1% && set /a numdeci=%numdeci% + 1 ! if exist decimals && set /a N=%N%%%decimals:~0,1% && set decimals=%decimals:~1%%0 && set /a numdeci=%numdeci% + 1 ! set /a N=%N%%0 && set /a numdeci=%numdeci% + 1 &; if %N%<=0x7FFFFFFFFFFFFFFF && set /a factor1=%factor1% - 1 && goto :longerdividendloop ! set "message=Longer Division out of range" && goto :endlocal
:longerdividendloop1
if not exist N1 && if not exist decimals && if exist decimal1 && set decimals=%decimal1% && set decimal1=
if not exist N1 && call :">=" ">=" "%N%.%decimals%" "%number2%" &; if %result%==0 &; if exist decimal1 && set /a N=%N%%%decimal1:~0,1% && set decimal1=%decimal1:~1% && set /a numdeci=%numdeci% + 1 ! if exist decimals && set /a N=%N%%%decimals:~0,1% && set decimals=%decimals:~1%%0 && set /a numdeci=%numdeci% + 1 ! set /a N=%N%%0 && set /a numdeci=%numdeci% + 1 &; if %N%<=0x7FFFFFFFFFFFFFFF && set /a factor1=%factor1% - 1 && set result= && goto :longerdividendloop1 ! set "message=Longer Division out of range" && goto :endlocal
if exist N1 && call :">=" ">=" "%N%" "%number2%" &; if %result%==0 &; set /a N=%N%%%N1:~0,1% && set N1=%N1:~1% &; set /a factor1=%factor1% - 1 && set result= && goto :longerdividendloop1
set D=0
if not exist N1 && if %result%==1 && set result= && call :- - "%N%.%decimals%" "%number2%" &; if exist result && set remainer=%result% && set D=1 && set result= ! goto :endlocal
if exist N1 && if %result%==1 && set result= && call :- - "%N%" "%number2%" &; if exist result && set remainer=%result% && set D=1 && set result= ! goto :endlocal
if %factor1%<=-1 && set factor1=0
set /a maxdeci=19 + %factor1%
#OLD#if not %divloops%<=%maxloops% && set /a maxloops=%maxloops% + 19 && set end=Y
goto :longerdividerloop
:longerdividendloop2
if %N1%>=1 && set decimals=%decimals%%0 && set comma=Y
if not %N1%>=1 && if exist decimal1 && set decimals=%decimals%%%decimal1:~0,1% && set decimal1=%decimal1:~1% && set comma=Y
if not %N1%>=1 && if not exist decimal1 && set decimals=%decimals%%0 && set comma=Y
set /a numdeci=%numdeci% + 1
set /a N=%N%%%decimals:~0,1% && set decimals=%decimals:~1%
call :">=" ">=" "%N%.%decimals%" "%number2%" &; if %result%==0 && set sum=%sum%%0 && if not %numdeci%>=%maxdeci% && set result= && goto :longerdividendloop2
set D=0
if %result%==1 && call :- - "%N%.%decimals%" "%number2%" &; if exist result && set remainer=%result% && set D=1 && set result= ! goto :endlocal
if %result%==0 && if %numdeci%==%maxdeci% && goto :longerdividerend
set result=
:longerdividerloop
if exist remainer && call :">=" ">=" "%remainer%" "%number2%" &; if %result%==1 && set result= && call :- - "%remainer%" "%number2%" &; if exist result && set remainer=%result% && set /a D=%D% + 1 && set result= && goto :longerdividerloop ! goto :endlocal
if %result%==0 && set sum=%sum%%%D% &; set /a sumlen=%@retval%
#OKE#echo "if exist remainer && if not %numdeci%>=%maxdeci% && call :splitnumber "%remainer%" &; set /a divloops=%divloops% + 1 && set remainer= &; goto :longerdividendloop2
if exist remainer && if not %numdeci%>=%maxdeci% && call :splitnumber "%remainer%" &; set remainer= &; goto :longerdividendloop2
#OLD#if exist remainer && if not %numdeci%>=%maxdeci% && call :splitnumber "%remainer%" &; set /a divloops=%divloops% + 1 && set remainer= && goto :longerdividendloop2
:longerdividerend
if not exist remainer && call :- - "%N%.%decimals%" "%number2%" &; if exist result && set remainer=%result% && set result= &; call :"==" "==" "%remainer%" "-%number2%" &; if %result%==1 && set remain=0 && set remainer= && set result= ! set remainer= && set result=
set sum=%sum% &; set /a sumlen=%@retval% && if not exist sum && set sumlen=0
set sum=0000000000000000000%sum%
set /a numdeci=%numdeci% - %numdeci0%
if %numdeci%>=1 && call set /a integer=%^sum:~0,-%numdeci%%% && call set decimals=%^sum:~-%numdeci%,%numdeci%%% ! call set /a integer=%sum%
if not %numdeci%>=0 && set zeros=0000000000000000000 && set /a numzeros=-1 * %numdeci% &; call set zeros=%^zeros:~0,%numzeros%%% &; set /a integer=%integer%%%zeros%
if exist N1 && if not exist division && set division=0
if %factor1%>=1 && call :shiftcomma "%integer%.%decimals%" "%factor1%" &; if exist N && set integer=%N% && set N= ! set rounded= && set "message=Multiplying in Long Division out of range" && goto :endlocal
if exist N1 && set factor1=
set maxdeci=19
if exist division && call :summing "%integer%.%decimals%" "%division%" &; if exist N && set division=%N%.%decimals% && set N= && set decimals= ! set rounded= && set "message=Summation in Long Divider out of range" && goto :endlocal
if exist N1 && set N1=%N1% &; set /a N1len=%@retval%
if exist N1 &; if %N1len%>=2 && set /a factor1=%N1len% - 1 ! set factor1=0
if %N1%>=10 && set numdeci=0 && set /a maxdeci=19 + %factor1% && set /a N=%N1:~0,1% && set N1=%N1:~1% && set decimals= && set sum= && goto :longerdividendloop
if %N1%>=1 && set numdeci=0 && set maxdeci=19 && set /a N=%N1% && set N1= && set decimals= && set sum= && goto :longerdividendloop1
if %N1%==0 && if exist decimal1 && set numdeci=0 && set maxdeci=19 && set N=0 && set N1= && set decimals= && set sum= && goto :longerdividendloop1
if exist division && call :"==" "==" "%division%" "0" &; if %result%==0 && set result= && call :splitnumber "%division%" &; set integer=%N% && set decimals=%decimals%
if exist decimals && set decimals=%decimals% &; set /a numdeci=%@retval%
if %numdeci%>=%maxdeci% && set numdeciO=%numdeci% && set /a numdeci=%maxdeci% - 1 && call set decimals=%^decimals:~0,%maxdeci%%% &; if not %decimals:~-1,1%==0 && set rounded=Y
if exist numdeciO && if not %numdeci%>=%numdeciO% &; if %decimals:~-1,1%>=5 && set /a decimal=%decimals:~0,-1% + 1 && set lastrnd=1 ! set /a decimal=%decimals:~0,-1% && set lastrnd=0 &; set decimal=000000000000000000%decimal% &; call set decimals=%^decimal:~-%numdeci%,%numdeci%%% && call set round=%^decimal:~0,-%numdeci%%% &; if %round%>=1 && set /a integer=%integer% + %round%
if not %rounded%==Y && if not exist remainer && if not %remain%==0 && set rounded=Y
if not %rounded%==Y && if exist remainer && call :"==" "==" "%remainer%" "0" &; if %result%==0 && set rounded=Y && set result= ! set result=
if exist decimals && set quotient=%integer%.%decimals% ! set quotient=%integer%
if exist factor &; if %factor%>=1 && set multiply=000000000000000000 &; call set multiply=1%^multiply:~0,%factor%%% &; call :* * "%quotient%" "%multiply%" &; if exist result && set quotient=%result% && set result= ! goto :endlocal
if exist factor &; if %factor%<=-1 && set multiply=00000000000000000 && set /a factor=-1 * %factor% - 1 &; call set multiply=0.%^multiply:~0,%factor%%%%1 &; call :* * "%quotient%" "%multiply%" &; if exist result && set quotient=%result% && set result= ! goto :endlocal
set sign=- &; if not "%sign1%"=="-1" && if not "%sign2%"=="-1" && set sign= ! if "%sign1%"=="-1" && if "%sign2%"=="-1" && set sign=
set result=%sign%%%quotient%
goto :endlocal
::
:summing
setlocal && set * && set maxdeci=%maxdeci%
set N1=%~n1 &; if not exist N1 && set N1=0 ! if "%N1:~0,1%"=="-" && set "sign1=-" && set N1=%N1:~1%
set decimal1=%~x1 &; set decimal1=%decimal1:~1% &; set /a numdeci1=%@retval% && if not exist decimal1 && set numdeci1=0
set N2=%~n2 &; if not exist N2 && set N2=0 ! if "%N2:~0,1%"=="-" && set "sign2=-" && set N2=%N2:~1%
set decimal2=%~x2 &; set decimal2=%decimal2:~1% &; set /a numdeci2=%@retval% && if not exist decimal2 && set numdeci2=0
if %numdeci1%==0 && if %N1%==0 && endlocal && set N=%N2% && set decimals=%decimal2% && set numdeci=%numdeci2% && goto :eof
if %numdeci2%==0 && if %N2%==0 && endlocal && set N=%N1% && set decimals=%decimal1% && set numdeci=%numdeci1% && goto :eof
if not %numdeci1%>=%numdeci2% && set numdeci=%numdeci2% ! set numdeci=%numdeci1%
if %numdeci%==0 && set /a N=%N1% + %N2% &; endlocal && set N=%N% && set decimals= && set numdeci=0 && goto :eof
if %numdeci%>=1 && set decimal1=%decimal1%%00000000000000000000000000000000000000
if %numdeci%>=1 && set decimal2=%decimal2%%00000000000000000000000000000000000000
if not %numdeci%<=%maxdeci% && set numdeci=%maxdeci%
call set decimal1=%^decimal1:~0,%numdeci%%%
call set decimal2=%^decimal2:~0,%numdeci%%%
if not %numdeci%<=17 && set /a taillen=%numdeci% - 17 && set /a taildeci=%decimal1:~17% + %decimal2:~17% &; set taildeci=00%taildeci% &; call set /a deci17=%^taildeci:~0,-%taillen%%% && call set taildeci=%^taildeci:~-%taillen%,%taillen%%%
if not %numdeci%<=17 && set /a decimals=%decimal1:~0,17% + %decimal2:~0,17% + %deci17% &; set decimals=00000000000000000%decimals% &; set /a N=%N1% + %N2% + %decimals:~0,-17% && set decimals=%decimals:~-17,17% &; set decimals=%decimals%%%taildeci%
if %numdeci%<=17 && set /a decimals=%decimal1% + %decimal2% &; set decimals=00000000000000000%decimals% &; call set /a N=%N1% + %N2% + %^decimals:~0,-%numdeci%%% && call set decimals=%^decimals:~-%numdeci%,%numdeci%%%
endlocal && set N=%N% && set decimals=%decimals% && set numdeci=%numdeci%
goto :eof
::
:shiftcomma
setlocal && set *
set N=%~n1 &; if not exist N && set N=0 ! if "%N:~0,1%"=="-" && set "sign=-" && set N=%N:~1%
set decimals=%~x1 &; set decimals=%decimals:~1%
set shift=%~2
if %shift%>=1 && set decimals=%decimals%%0000000000000000000 &; set /a numdecis=%@retval%
if %shift%>=1 &; if exist decimals && call set N=%N%%%^decimals:~0,%shift%%% && call set decimals=%^decimals:~%shift%%%
if %shift%>=1 &; if not %decimals%==0 && set decimals=%decimals:~0,19% && set numdeci=19 ! set decimals= && set numdeci=0
if %shift%>=1 && endlocal && set N=%N% && set decimals=%decimals% && set numdeci=%numdeci% && goto :eof
if exist decimals && set /a numdeci=%@retval% ! set numdeci=0
set sum=0000000000000000000%N%%%decimals% &; set /a numints=%@retval%
set /a numdeci=%numdeci% - %shift% &; if %numdeci%>=1 && call set /a N=%^sum%:~0,-%numdeci%%% && call set decimals=%^sum:~-%numdeci%,%numdeci%%%
if not %decimals%==0 && set decimals=%decimals:~0,19% && set numdeci=19 ! set decimals= && set numdeci=0
echo %0 && set
endlocal && set N=%N% && set decimals=%decimals% && set numdeci=%numdeci%
goto :eof
::
:splitnumber
setlocal
set N=
set decimals=
set N=%~n1 &; if not exist N && set N=0 ! if "%N:~0,1%"=="-" && set "sign=-" && set N=%N:~1%
set decimals=%~x1 &; set decimals=%decimals:~1% &; set /a numdecis=%@retval% && if not exist decimals && set numdecis=0
endlocal && set N=%N% && set decimals=%decimals% && set numdecis=%numdecis%
goto :eof
::
:^
#-#+ ^ \tOperator  ^ : Decimal exponentiation of base number1 and power number2
#-# Use\tCALCD.G4B [switch] number1 ^ number2\nRemarks\tInfix operator, existing result can be used instead of number1\n\tNegative exponent and/ or decimals/ fractions in exponent supported\n\tNegative base allowed, except with decimals/ fractions in exponent!\n\tInternally 73 digits, 19th decimal is used for rounding\n\tHighest base: 3,037,000,499.976049692286752403 (power: 2)\nExample CALCD.G4B 2 ^ 8\nExample CALCD.G4B -2 ^ 8\nExample CALCD.G4B 1.02 ^ 35\nExample CALCD.G4B 5.0512 ^ 2\nExample CALCD.G4B 0.0123456789 ^ 5\nExample CALCD.G4B 1k ^ 6 THSEP\nExample CALCD.G4B 1.0123456789 ^ 3,558 THSEP\nExample CALCD.G4B 3,037,000,499.976049692286752403 ^ 2 HEX\nExample CALCD.G4B 3,037,000,499.976049692286752403 ^ 2 ROUND 0 HEX\nExample CALCD.G4B --echoR 0.0123456789^5MS0.0123456789^4MNMR\nExample CALCD.G4B -3 ^ -3\nExample CALCD.G4B 0.3 ^ 0.3\nExample CALCD.G4B 1:3piMS 1:3pi^3/3!MN 1:3pi^5/5!MP 1:3pi^7/7!MN\n\t\t   1:3pi^9/9!MP1:3pi^11/11!MN 1:3pi^13/13!MP\nExample CALCD.G4B 1MS 1:3pi^2*3/3!MN 1:3pi^4*5/5!MP 1:3pi^6*7/7!MN\n\t\t   1:3pi^8*9/9!MP 1:3pi^10*11/11!MN 1:3pi^12*13/13!MP
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~3"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
if /i "%~1"=="noround" && set noround=Y && set lastrnd= ! set noround=N
shift
set n1=%~1 &; if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
set n2=%~2 &; if /i %n2:~-2,2%==mr && set n2=%n2:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n2%==r && set n2=%R% ! if /i %n2%==-r && set n2=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
call Fn.11 "%n2%" "/" && set "message=Abort %0: fractioned power '%~2' unsupported" && goto :endlocal
if /i "%n2:~-1,1%"=="!" && set n2=%n2:~0,-1% &; if %n2:~0,1%==- && set n2=%n2:~1% && set sign=- ! set sign= &; call :fact goback %n2% &; if exist result && set n2=%sign%%%result% && set result= ! set rounded= && goto :endlocal
call :operatorsinput %0 "%n1%" "%n2%" &; if exist message && goto :endlocal
if %sign2%==-1 && set INV=Y && set sign2=
if %sign1%==-1 && if exist decimal2 &; if exist decimal1 && set "message=Abort %0: complex power '(-%N1%.%decimal1%) ^ %N2%.%decimal2%' unsupported" ! set "message=Abort %0: complex power '(-%N1%) ^ %N2%.%decimal2%' unsupported" &; goto :endlocal
set power=%N2% && set N2=
if exist decimal2 &; if exist decimal1 && set base=%N1%.%decimal1% ! set base=%N1%
if %power%==0 && if not exist decimal2 &; if not %rounded%==Y && set result=1 && goto :endlocal
if %power%==1 && if not exist decimal2 &; if %INV%==Y && if exist decimal1 && call :/ / 1 %N1%.%decimal1% ! if %INV%==Y && call :/ / 1 %N1% ! if exist decimal1 && set result=%N1%.%decimal1% ! set result=%N1% &; if %sign1%==-1 && set result=-%result% ! set result=%result% &; goto :endlocal
#BAD#if %power%==1 && if not exist decimal2 &; if %INV%==Y && if exist decimal1 && call :/ / 1 %N1%.%decimal1% ! if %INV%==Y && call :/ / 1 %N1% ! set result=%~1 &; goto :endlocal
if %power%<=1 && if exist decimal2 &; if %power%==0 && set result=1 ! set result=%base% &; goto :getlnandex
if %N1%==0 && if %numdeci1%==0 && if not exist decimal2 &; set result=1 && goto :endlocal
set orgpower=%power%
if %numdeci1%==0 && set N2=%N1% && goto :calcpowerloop2
set N1=000000000000000000000000000%N1%
set d1=%decimal1%%000000000000000000000000000000000000000000000000000000 && set decimal1= && set numdeci1=
set * && set rounded=%rounded% && set power=%power% && set orgpower=%orgpower% && set N1=%N1% && set d1=%d1% && set sign1=%sign1% && set noround=%noround% && set INV=%INV% && set decimal2=%decimal2% && set base=%base%
set /a N1C=%N1:~-27,9% && set /a N1B=%N1:~-18,9% && set /a N1A=%N1:~-9,9% && set N1=
set N2C=%N1C% && set N2B=%N1B% && set N2A=%N1A%
set d1A=%d1:~0,9% && set d1B=%d1:~9,9% && set d1C=%d1:~18,9% && set d1D=%d1:~27,9% && set d1E=%d1:~36,9% && set d1F=%d1:~45,9%
set d2A=%d1A% && set d2B=%d1B% && set d2C=%d1C% && set d2D=%d1D% && set d2E=%d1E% && set d2F=%d1F%
:calcpowerloop
setlocal
set /a N1Ad2F=%N1A% * %d2F%
set /a N2Ad1F=%N2A% * %d1F%
set /a d1Ad2E=%d1A% * %d2E%
set /a d2Ad1E=%d2A% * %d1E%
set /a d1Bd2D=%d1B% * %d2D%
set /a d2Bd1D=%d2B% * %d1D%
set /a d1Cd2C=%d1C% * %d2C%
set /a SumEm54=%N1Ad2F% + %N2Ad1F% + %d1Ad2E% + %d2Ad1E% + %d1Bd2D% + %d2Bd1D% + %d1Cd2C%
set d1d2m54=%SumEm54:~-9,9% && set /a SEm54p9=%SumEm54:~0,-9%
set d1d2m54=000000000%d1d2m54%
set d1d2m54=%d1d2m54:~-9,9%
endlocal && set d1d2m54=%d1d2m54% && set SEm54p9=%SEm54p9%
setlocal
set /a N1Bd2F=%N1B% * %d2F%
set /a N2Bd1F=%N2B% * %d1F%
set /a N1Ad2E=%N1A% * %d2E%
set /a N2Ad1E=%N2A% * %d1E%
set /a d1Ad2D=%d1A% * %d2D%
set /a d2Ad1D=%d2A% * %d1D%
set /a d1Bd2C=%d1B% * %d2C%
set /a d2Bd1C=%d2B% * %d1C%
set /a SumEm45=%N1Bd2F% + %N2Bd1F% + %N1Ad2E% + %N2Ad1E% + %d1Ad2D% + %d2Ad1D% + %d1Bd2C% + %d2Bd1C% + %SEm54p9%
set d1d2m45=%SumEm45:~-9,9% && set /a SEm45p9=%SumEm45:~0,-9%
set d1d2m45=000000000%d1d2m45%
set d1d2m45=%d1d2m45:~-9,9%
endlocal && set d1d2m45=%d1d2m45% && set SEm45p9=%SEm45p9% && set SEm54p9=
setlocal
set /a N1Cd2F=%N1C% * %d2F%
set /a N2Cd1F=%N2C% * %d1F%
set /a N1Bd2E=%N1B% * %d2E%
set /a N2Bd1E=%N2B% * %d1E%
set /a N1Ad2D=%N1A% * %d2D%
set /a N2Ad1D=%N2A% * %d1D%
set /a d1Ad2C=%d1A% * %d2C%
set /a d2Ad1C=%d2A% * %d1C%
set /a d1Bd2B=%d1B% * %d2B%
set /a SumEm36=%N1Cd2F% + %N2Cd1F% + %N1Bd2E% + %N2Bd1E% + %N1Ad2D% + %N2Ad1D% + %d1Ad2C% + %d2Ad1C% + %d1Bd2B% + %SEm45p9%
set d1d2m36=%SumEm36:~-9,9% && set /a SEm36p9=%SumEm36:~0,-9%
set d1d2m36=000000000%d1d2m36%
set d1d2m36=%d1d2m36:~-9,9%
endlocal && set d1d2m36=%d1d2m36% && set SEm36p9=%SEm36p9% && set SEm45p9=
setlocal
set /a N1Cd2E=%N1C% * %d2E%
set /a N2Cd1E=%N2C% * %d1E%
set /a N1Bd2D=%N1B% * %d2D%
set /a N2Bd1D=%N2B% * %d1D%
set /a N1Ad2C=%N1A% * %d2C%
set /a N2Ad1C=%N2A% * %d1C%
set /a d1Ad2B=%d1A% * %d2B%
set /a d2Ad1B=%d2A% * %d1B%
set /a SumEm27=%N1Cd2E% + %N2Cd1E% + %N1Bd2D% + %N2Bd1D% + %N1Ad2C% + %N2Ad1C% + %d1Ad2B% + %d2Ad1B% + %SEm36p9%
set d1d2m27=%SumEm27:~-9,9% && set /a SEm27p9=%SumEm27:~0,-9%
set d1d2m27=000000000%d1d2m27%
set d1d2m27=%d1d2m27:~-9,9%
if %power%==2 && if %noround%==N &; if %d1d2m27:~-9,1%>=5 && set /a SEm27p9=%SEm27p9% + 1 && set lastrnd=1 ! set lastrnd=0
endlocal && set d1d2m27=%d1d2m27% && set SEm27p9=%SEm27p9% && set lastrnd=%lastrnd% && set SEm36p9=
setlocal
set /a N1Cd2D=%N1C% * %d2D%
set /a N2Cd1D=%N2C% * %d1D%
set /a N1Bd2C=%N1B% * %d2C%
set /a N2Bd1C=%N2B% * %d1C%
set /a N1Ad2B=%N1A% * %d2B%
set /a N2Ad1B=%N2A% * %d1B%
set /a d1Ad2A=%d1A% * %d2A%
set /a SumEm18=%N1Cd2D% + %N2Cd1D% + %N1Bd2C% + %N2Bd1C% + %N1Ad2B% + %N2Ad1B% + %d1Ad2A% + %SEm27p9%
set d1d2m18=%SumEm18:~-9,9% && set /a SEm18p9=%SumEm18:~0,-9%
set d1d2m18=000000000%d1d2m18%
set d1d2m18=%d1d2m18:~-9,9%
endlocal && set d1d2m18=%d1d2m18% && set SEm18p9=%SEm18p9% && set SEm27p9=
setlocal
set /a N1Cd2C=%N1C% * %d2C%
set /a N2Cd1C=%N2C% * %d1C%
set /a N1Bd2B=%N1B% * %d2B%
set /a N2Bd1B=%N2B% * %d1B%
set /a N1Ad2A=%N1A% * %d2A%
set /a N2Ad1A=%N2A% * %d1A%
set /a SumEm9=%N1Cd2C% + %N2Cd1C% + %N1Bd2B% + %N2Bd1B% + %N1Ad2A% + %N2Ad1A% + %SEm18p9%
set d1d2m9=%SumEm9:~-9,9% && set /a SEm9p9=%SumEm9:~0,-9%
set d1d2m9=000000000%d1d2m9%
set d1d2m9=%d1d2m9:~-9,9%
endlocal && set d1d2m9=%d1d2m9% && set SEm9p9=%SEm9p9% && set SEm18p9=
setlocal
set /a N1Cd2B=%N1C% * %d2B%
set /a N2Cd1B=%N2C% * %d1B%
set /a N1Bd2A=%N1B% * %d2A%
set /a N2Bd1A=%N2B% * %d1A%
set /a N1AN2A=%N1A% * %N2A%
set /a SumEp0=%N1Cd2B% + %N2Cd1B% + %N1Bd2A% + %N2Bd1A% + %N1AN2A% + %SEm9p9%
set SumEp0=0000000000%SumEp0%
set N1N2p0=%SumEp0:~-9,9% && set /a SE0p9=%SumEp0:~0,-9%
set N1N2p0=000000000%N1N2p0%
set N1N2p0=%N1N2p0:~-9,9%
endlocal && set N1N2p0=%N1N2p0% && set SE0p9=%SE0p9% && set SEm9p9=
setlocal
set /a N1Cd2A=%N1C% * %d2A%
set /a N2Cd1A=%N2C% * %d1A%
set /a N1BN2A=%N1B% * %N2A%
set /a N2BN1A=%N2B% * %N1A%
set /a SumEp9=%N1Cd2A% + %N2Cd1A% + %N1BN2A% + %N2BN1A% + %SE0p9%
set SumEp9=0000000000%SumEp9%
set N1N2p9=%SumEp9:~-9,9% && set /a SE9p9=%SumEp9:~0,-9%
endlocal && set N1N2p9=%N1N2p9% && set SE9p9=%SE9p9% && set SE0p9=
setlocal
set /a N1B2B=%N1B% * %N2B%
set /a N1CN2A=%N1C% * %N2A%
set /a N2CN1A=%N2C% * %N1A%
set /a SumEp18=%N1B2B% + %N1CN2A% + %N2CN1A% + %SE9p9%
set SumEp18=000000000%SumEp18%
set N1N2p18=%SumEp18:~-9,9% && set /a SE18p9=%SumEp18:~0,-9%
endlocal && set N1N2p18=%N1N2p18% && set SE18p9=%SE18p9% && set SE9p9=
if not %N1N2p18%<=9 && set "message=Exponentiation out of range" && goto :endlocal
if not %N1N2p18%<=9223372036 && if not %N1N2p9%<=854775807 && set "message=Exponentiation out of range" && goto :endlocal
set /a power=%power% - 1 &; if %power%>=2 && set N1C=%N1N2p18% && set N1N2p18= && set N1B=%N1N2p9% && set N1N2p9= && set N1A=%N1N2p0% && set N1N2p0= && set d1A=%d1d2m9% && set d1d2m9= && set d1B=%d1d2m18% && set d1d2m18= && set d1C=%d1d2m27% && set d1d2m27= && set d1D=%d1d2m36% && set d1d2m36= && set d1E=%d1d2m45% && set d1d2m45= && goto :calcpowerloop
if not %d1d2m54%==0 && set rounded=Y ! if not %d1d2m45%==0 && set rounded=Y ! if not %d1d2m36%==0 && set rounded=Y ! if not %d1d2m27%==0 && set rounded=Y
if %d1d2m18%==0 && set d1d2m18=
if %noround%==Y && set lastrnd=%d1d2m27%%%d1d2m36%%%d1d2m45%
set resdec=%d1d2m9%%%d1d2m18% &; if %resdec%==0 && set resdec=
if %N1N2p18%>=1 && set /a N1N2p18=%N1N2p18%
if %N1N2p18%==0 && set N1N2p18= && set /a N1N2p9=%N1N2p9%
if %N1N2p18%==0 && if %N1N2p9%==0 && set N1N2p18= && set N1N2p9= && set /a N1N2p0=%N1N2p0%
set resint=%N1N2p18%%%N1N2p9%%%N1N2p0%
if %resint%==0 && set resint=0
set resdec=%resdec:~0,18%
if %resint%>=1 && call :stripzerosbefore "%resint%" &; set resint=%result% && set result=
goto :calcpowerloopend
:calcpowerloop2
if not %N1N2%<=0x7FFFFFFFFFFFFFFF && set "message=Exponentiation out of range" && goto :endlocal
if %N1%>=0x4000000000000000 && set "message=Exponentiation out of range" && goto :endlocal
set /a N1N2=%N1% * %N2% &; if %N1%>=0 && if %N1N2%<=0 && set "message=Exponentiation out of range" && goto :endlocal
set /a power=%power% - 1 &; if %power%>=2 && set N1=%N1N2% && goto :calcpowerloop2 ! set resint=%N1N2%
:calcpowerloopend
if not %resint%<=0x7FFFFFFFFFFFFFFF && set "message=Exponentiation out of range" && goto :endlocal
if exist resdec && if not exist fix && if %noround%==N && call :stripzerosafter "%resdec%" &; set resdeci=%result% && set result=
if "%sign1%"=="-1" && set sign=- &; calc %orgpower% % 2 || set sign=
if not exist resdec && if not %rounded%==Y && set result=%sign%%%resint% ! if exist resdec && set result=%sign%%%resint%.%resdec% ! set result=%sign%%%resint%
if exist decimal2 && goto :getlnandex
if %INV%==Y && call :/ / 1 "%result%"
goto :endlocal
::
:getlnandex
set RESULT=%result% && set result= && call :ln ln "%base%" &; if exist message && goto :endlocal ! if exist result && set ln=%result% ! goto :endlocal
if exist ln && if exist decimal2 &; set result= && call :* * "0.%decimal2%" "%ln%" &; if exist message && goto :endlocal ! if exist result && set ln2=%result% ! goto :endlocal
if exist ln2 && if exist decimal2 &; set result= && call :ex ex "%ln2%" &; if exist message && goto :endlocal ! if exist result && set ex=%result% ! goto :endlocal
if exist ex && if exist RESULT &; set result= && call :* * "%RESULT%" "%ex%" &; if exist message && goto :endlocal ! if not exist result && goto :endlocal
if %INV%==Y && call :/ / 1 "%result%"
goto :endlocal
::
:sqrt
#-#+ SQRT \tFunction SQRT - Decimal square root of number before
#-# Use\tCALCD.G4B number SQRT\nRemarks\tPostfix function, existing result can be used instead of number\n\tInternally 38 digits, 19th decimal is used for rounding\nExample CALCD.G4B 10 SQRT\nExample CALCD.G4B 19.1844 SQRT\nExample CALCD.G4B 2050.456 SQRT\nExample CALCD.G4B 0x7FFFFFFFFFFFFFFF SQRT\nExample CALCD.G4B 1234567890987654321.123456789987654321 SQRT\nExample CALCD.G4B 256 * 256 SQRT ^ 2\nExample CALCD.G4B --echoR 123,456,789.123456789 SQRT SQRT SQRT SQRT ^ 16 round 9\nExample CALCD.G4B --echoR 256SQRTMS4096SQRTMPMR
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~2"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
shift
set n1=%~1 &; if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
call :operatorsinput %0 "%n1%" &; if exist message && goto :endlocal ! set n1=
if "%sign1%"=="-1" && set "message=Abort %0: negative number %sign1:~0,1%%%N1%" && goto :endlocal
set N1=%N1% &; set /a N1len=%@retval%
set /a N=%N1% &; set /a Nlen=%@retval% &; calc %Nlen% % 2 && set N=0%N% &; set /a Nlen=%@retval%
if exist decimal1 && set decimal=%decimal1% &; set /a decilen=%@retval% &; calc %decilen% % 2 && set decimal=%decimal%%0 && set /a decilen=%decilen% + 1
if exist decimal && set N=%N%%%decimal% && set /a decilen=%decilen% / 2 ! set decilen=0
set start2dg=%N:~0,2% && set N=%N:~2% &; set /a Nlen=%@retval%
set sqrt=9
:sqrtloop
set /a proxy=%sqrt% * %sqrt%
set /a remainer=%start2dg% - %proxy% &; if not %remainer%>=0 && set /a sqrt=%sqrt% - 1 && goto :sqrtloop
if not exist N &; if %remainer%>=1 && set N=000000000000000000000000000000000000 && set end=Y && set numdeci=1 ! set result=%sqrt% && goto :endlocal
set remainer=%remainer%%%N:~0,2% && set N=%N:~2%
set D=9
:calcsqrtloop
set /a proxy=20 * %sqrt% + %D% * %D%
if not %proxy%<=%remainer% && set /a D=%D% - 1 && goto :calcsqrtloop ! set sqrt=%sqrt%%%D% && set /a remainer=%remainer% - %proxy% && set D=9
if not exist N && if %remainer%>=1 && if not %end%==Y && set N=000000000000000000000000000000000000 && set end=Y && set numdeci=0
if exist N && if not %remainer%<=10248191152060862 && set remainer=%remainer%%%N:~0,2% && set N=%N:~2% &; if exist numdeci && set /a numdeci=%numdeci% + 1 ! set numdeci=0 &; set D=9 && goto :calclongsqrtloop
if not exist N && if %remainer%>=1 && set rounded=Y
if not exist N && if not %numdeci%>=1 && if not %decilen%>=1 && set integer=%sqrt% && goto :calcsqrtend
if not exist N && if not %numdeci%>=1 && if %decilen%>=1 && set numdeci=%decilen% &; call set integer=%^sqrt:~0,-%numdeci%%% && call set decimals=%^sqrt:~-%numdeci%,%numdeci%%% && goto :calcsqrtend
if not exist N && if %numdeci%>=1 && set /a numdeci=%numdeci% + %decilen% &; call set integer=%^sqrt:~0,-%numdeci%%% && call set decimals=%^sqrt:~-%numdeci%,%numdeci%%% && goto :calcsqrtend
set remainer=%remainer%%%N:~0,2% && set N=%N:~2%
if %end%==Y && set /a numdeci=%numdeci% + 1
goto :calcsqrtloop
:calcsqrtend
if %numdeci%>=19 && set decimals=%decimals:~0,19% && set numdeci=19
if not %remainer%==0 && if exist decimals &; if %decimals:~-1,1%>=5 && set round=1 && set lastrnd=1 ! set round=0 && set lastrnd=0 &; set decimals=%decimals:~0,-1% && set /a numdeci=%numdeci% - 1 &; set /a decimals=%decimals% + %round% &; set decimals=00000000000000000000000000000000000000%decimals% &; call set /a integer=%integer% + %^decimals:~0,-%numdeci%%% && call set decimals=%^decimals:~-%numdeci%,%numdeci%%%
if exist decimals && set result=%integer%.%decimals% ! set result=%integer%
goto :endlocal
::
:calclongsqrtloop
set /a Dx20=20 * %D%
set /a Dexp2=%D% * %D%
set /a proxylo=%Dx20% * %sqrt:~-16,16%
set /a carry=%proxylo:~0,-16%
set /a proxylo=%proxylo:~-16,16% + %Dexp2%
set proxylo=00000000000000000%proxylo% &; set proxylo=%proxylo:~-16,16%
set /a sqrthi=%sqrt:~0,-16%
set /a proxyhi=%Dx20% * %sqrthi% + %carry%
set proxy=%proxyhi%%%proxylo% &; set /a proxylen=%@retval%
set remainer=%remainer% &; set /a remainln=%@retval%
set greater=
set remainlo=%remainer:~-16,16%
set remainhi=%remainer:~0,-16%
if %proxyhi%==%remainhi% && set equal=Y ! set equal=N
if not %equal%==Y &; if not %proxyhi%<=%remainhi% && set greater=Y ! set greater=N
if %equal%==Y &; if not %proxylo%<=%remainlo% && set greater=Y ! set greater=N
if %greater%==Y && set /a D=%D% - 1 && goto :calclongsqrtloop
set sqrt=%sqrt%%%D%
set /a remainlo=%remainer:~-16,16% - %proxy:~-16,16%
if %remainlo%<=-1 && set /a remainlo=1%remainer:~-16,16% - %proxy:~-16,16% && set lend=1 ! set lend=0
set remainlo=00000000000000000%remainlo% &; set remainlo=%remainlo:~-16,16%
set /a remainer=%remainer:~0,-16% && set /a proxy=%proxy:~0,-16%
set /a remainhi=%remainer% - %lend% - %proxy%
set remainer=%remainhi%%%remainlo% &; set /a remainln=%@retval%
if not exist end2 && if not exist N && set N=0000000000000000000000000000 && set end2=Y && if not exist numdeci && set numdeci=0
if %remainer%==0 && set N=
if %numdeci%>=19 && set N=
if %remainln%>=32 && set N=
if not exist N && if not %remainer%==0 && set rounded=Y
if not exist N && if not %numdeci%>=1 && if not %decilen%>=1 && set integer=%N% && goto :calcsqrtend
if not exist N && if not %numdeci%>=1 && if %decilen%>=1 && set numdeci=%decilen% &; set sqrt=%N%%%decimals% &; call set integer=%^sqrt:~0,-%numdeci%%% && call set decimals=%^sqrt:~-%numdeci%,%numdeci%%% && goto :calcsqrtend
if not exist N && if %numdeci%>=1 && set /a numdeci=%numdeci% + %decilen% &; call set integer=%^sqrt:~0,-%numdeci%%% && call set decimals=%^sqrt:~-%numdeci%,%numdeci%%% && goto :calcsqrtend
set remainer=%remainer%%%N:~0,2% && set N=%N:~2%
if not %end%==Y if not %end2%==Y || set /a numdeci=%numdeci% + 1
set D=9 && set greater= && set equal=
goto :calclongsqrtloop
::
:sum
#-#+ SUM \tFunction SUM - Sum of numbers behind
#-# Use 1\tCALCD.G4B SUM number1 number2 [number3 ...]\nUse 2\tCALCD.G4B SUM [MD] FILE\nRemarks Prefix function, result can be used as input to infix or postfix\n\tfunctions. New prefix function restarts calculation\n\tFILE must be an md-device containing numbers only, max 255 sectors\n\tSeparators in FILE: spaces (20), 0A or 0D0A - MD optional\nExample CALCD.G4B SUM 1 2 3\nExample CALCD.G4B SUM 1 -2 3\nExample CALCD.G4B SUM 1 2 3 / 3\nExample CALCD.G4B 4! MS SUM 1! 2! 3! MR 5!\nExample CALCD.G4B SUM 1 2 3 / 3 MS SUM 1 2 3 4 / 4 MP MR\nMake FILE: echo 0.5 1.5 2.5 3.5 4.5 5.5 0.05\x20>\x20(md)0x3000+255\nExample CALCD.G4B SUM (md)0x3000+255\nExample CALCD.G4B SUM (md)0x3000+255 * 0.7\nExample CALCD.G4B SUM (md)0x3000+255 MS2.5*MRMPMR
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if %~1==goback && set goback=Y
if "%~3"=="" &; if %goback%==Y && endlocal && set "message=Abort: argument(s) missing in SUM" && goto :eof ! endlocal && set "message=Abort: argument(s) missing in SUM" && goto :calcfpend
shift
if /i %~1==md &; if %~d2==(md) && set md=%~2 && shift && shift ! if %goback%==Y && endlocal && set "message=Abort SUM: (md)-device in '%~2' not found" && set result= && goto :eof ! endlocal && set "message=Abort: (md)-device in '%~2' not found" && goto :calcfpend
if %~d1==(md) && set md=%~1 && shift
if exist md &; call Fn.11 "%md%" "+" |; if %goback%==Y && endlocal && set "message=Abort SUM: (md)-device in '%md%' not valid" && set result= && goto :eof ! endlocal && set "message=Abort: (md)-device in '%md%' not valid" && goto :calcfpend
if exist md && if %md:~-3,3%>=256 &; if %goback%==Y && endlocal && set "message=Abort SUM: sectors of (md)-device in '%md%' above 255" && set result= && goto :eof ! endlocal && set "message=Abort: sectors of (md)-device in '%md%' above 255" && goto :calcfpend
if not exist md && set N1=%~1 &; if /i %N1:~-2,2%==mr && set N1=%N1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %N1%==r && set N1=%R% ! if /i %N1%==-r && set N1=-%R%
if not exist md && set N2=%~2 &; if /i %N2:~-2,2%==mr && set N2=%N2:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %N2%==r && set N2=%R% ! if /i %N2%==-r && set N2=-%R%
if not exist md && call :+ + %N1% %N2% &; if exist result && if not "%~3"=="" && shift && shift && goto :sumloop ! if %goback%==Y && endlocal && set "message=%message%" && set result=%result% && set rounded=%rounded% && goto :eof ! endlocal && set "message=%message%" && set result=%result% && set rounded=%rounded% && goto :calcfpend
cat %md% | call :sumloop  &; if "%~1"=="" &; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && set "message=%message%" && goto :eof ! endlocal && set "message=%message%" && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfpend
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfprestart
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if %goback%==Y && endlocal && set "message=%message%" && set result=%result% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set "message=%message%" && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfpend
:sumloop
if exist md && if "%~1"=="" && goto :eof
if exist md && if exist result && call :+ + "%result%" %~1 &; if not exist result && goto :eof
if exist md && if not exist result && call :+ + %~1 %~2 &; shift && if not exist result && goto :eof
if exist md && shift && goto :sumloop
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfprestart
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="" && set N1=%~1 &; if /i %N1:~-2,2%==mr && set N1=%N1:~0,-2%%%MR% && set lastrnd=%memrnd%
if not "%~1"=="" && call :+ + "%result%" %N1% &; if exist result && shift ! endlocal && set "message=%message%" && set result= && goto :eof
if not "%~1"=="" && goto :sumloop
if %goback%==Y && endlocal && set "message=%message%" && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof
endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && set "message=%message%"
goto :calcfpend
::
:count
#-#+ COUNT \tFunction COUNT - Count of argument(s) behind
#-# Use 1\tCALCD.G4B COUNT ARG1 [ARG2 ...]\nUse 2\tCOUNT [MD] FILE\nRemarks Prefix function, counting is ended by \\\\\n\tResult can be used as input to infix or postfix functions\n\tNew prefix function after \\\\ restarts calculation\n\tFILE must be an md-device, max 255 sectors (argument \\\\ ends COUNT)\n\tSeparators in FILE: spaces (20), 0A or 0D0A - MD optional\nExample CALCD.G4B COUNT 1 2 3 a B C * - + ^ / inv sqrt words symbols\nExample CALCD.G4B COUNT 1 2 3 a B C * - + ^ / inv sqrt words \\\\ - 3\nExample CALCD.G4B COUNT 1 2 3 a B C * - + ^ / inv sqrt words \\\\ MS 3 / MR\nMake FILE: echo 1 2 3 a B C * - + ^ / inv sqrt words\x20>\x20(md)0x3000+255\nExample CALCD.G4B COUNT (md)0x3000+255\nExample CALCD.G4B COUNT (md)0x3000+255 / 8\nExample CALCD.G4B COUNT (md)0x3000+255 MS SUM (md)0x3100+255 / MR
setlocal && set *
if %~1==goback && set goback=Y
if "%~2"=="" &; if %goback%==Y && endlocal && set "message=Abort: 'argument' is missing in COUNT" && goto :eof ! endlocal && set "message=Abort: 'argument' is missing in COUNT" && goto :calcfpend
shift
if /i %~1==md &; if %~d2==(md) && set md=%~2 && shift && shift ! if %goback%==Y && endlocal && set "message=Abort COUNT: (md)-device in '%~2' not found" && goto :eof ! endlocal && set "message=Abort COUNT: (md)-device in '%~2' not found" && goto :calcfpend
if %~d1==(md) && set md=%~1 && shift
if exist md &; call Fn.11 "%md%" "+" |; if %goback%==Y && endlocal && set "message=Abort COUNT: (md)-device in '%md%' not valid" && goto :eof ! endlocal && set "message=Abort COUNT: (md)-device in '%md%' not valid" && goto :calcfpend
if exist md && if %md:~-3,3%>=256 &; if %goback%==Y && endlocal && set "message=Abort COUNT: sectors of (md)-device in '%md%' above 255" && goto :eof ! endlocal && set "message=Abort COUNT: sectors of (md)-device in '%md%' above 255" && goto :calcfpend
set count=0
if not exist md && goto :countloop
#USERMUSTDO#cat --locate== --number=1 %md% > nul && cat --locate== --replace=- %md% > nul
#USERMUSTDO#cat --locate=% --number=1 %md% > nul && cat --locate=% --replace=# %md% > nul
#USERMUSTDO#cat --locate=\x22 --number=1 %md% > nul && cat --locate=\x22 --replace=\x27 %md% > nul
cat %md% | call :countloop  &; if %count%>=1 && set result=%count% ! endlocal && set "message=%message%" && goto :eof
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; if %goback%==Y && endlocal && set result=%result% && goto :eof ! endlocal && set result=%result% && goto :calcfploop
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; if %goback%==Y && endlocal && set result=%result% && goto :eof ! endlocal && set result=%result% && goto :calcfploop
if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; if %goback%==Y && endlocal && set result=%result% && goto :eof ! endlocal && set result=%result% && goto :calcfprestart
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; if %goback%==Y && endlocal && set result=%result% && goto :eof ! endlocal && set result=%result% && goto :calcfploop
if "%~1"=="\\" && shift
if %goback%==Y && endlocal && set "message=%message%" && set result=%result% && goto :eof ! endlocal && set "message=%message%" && set result=%result% && goto :calcfploop
:countloop
if "%~1"=="" && if exist md && goto :eof
set /a count=%count%+1 && shift
if exist md && goto :countloop ! if not "%~1"=="" && if not "%~1"=="\\" && goto :countloop
set result=%count%
if "%~1"=="\\" && shift &; if %goback%==Y && endlocal && set result=%result% && goto :eof ! endlocal && set result=%result% && goto :calcfploop
endlocal && set result=%result% && set "message=%message%"
goto :calcfpend
::
:mean
#-#+ MEAN \tFunction MEAN - Mean of numbers behind
#-#  Use 1\tCALCD.G4B MEAN number1 number2 [number3 ...]\nUse 2\tCALCD.G4B MEAN [MD] FILE\nRemarks Prefix function, result can be used as input to infix or postfix\n\tfunctions. New prefix function restarts calculation\n\tFILE must be an md-device containing numbers only, max 255 sectors\n\tSeparators in FILE: spaces (20), 0A or 0D0A - MD optional\nExample CALCD.G4B MEAN 1 2 3 4 5 6\nExample CALCD.G4B MEAN 1 2 3 4 5 6 * 6\nExample CALCD.G4B MEAN 1 2 3 4 5 6 MSMR*6\nMake FILE: echo 0.5 1.5 2.5 3.5 4.5 5.5 0.05\x20>\x20(md)0x3000+255\nExample CALCD.G4B MEAN (md)0x3000+255\nExample CALCD.G4B MEAN (md)0x3000+255 SQRT
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if %~1==goback && set goback=Y
if "%~3"=="" &; if %goback%==Y && endlocal && set "message=Abort: argument(s) missing in MEAN" && goto :eof ! endlocal && set "message=Abort: argument(s) missing in MEAN" && goto :calcfpend
shift
if /i %~1==md &; if %~d2==(md) && set md=%~2 && shift && shift ! if %goback%==Y && endlocal && set "message=Abort MEAN: (md)-device in '%~2' not found" && set result= && goto :eof ! endlocal && set "message=Abort MEAN: (md)-device in '%~2' not found" && set result= && goto :calcfpend
if %~d1==(md) && set md=%~1 && shift
if not exist md && set N1=%~1 &; if /i %N1:~-2,2%==mr && set N1=%N1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %N1%==r && set N1=%R% ! if /i %N1%==-r && set N1=-%R%
if not exist md && set N2=%~2 &; if /i %N2:~-2,2%==mr && set N2=%N2:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %N2%==r && set N2=%R% ! if /i %N2%==-r && set N2=-%R%
if not exist md && set count=1 && call :+ + %N1% %N2% &; if exist result && set /a count=%count%+1 && shift && shift && goto :meanloop ! endlocal && set "message=%message%" && set result= && goto :eof
call Fn.11 "%md%" "+" |; if %goback%==Y && endlocal && set "message=Abort MEAN: (md)-device in '%md%' not valid" && set result= && goto :eof ! endlocal && set "message=Abort MEAN: (md)-device in '%md%' not valid" && set result= && goto :calcfpend
if %md:~-3,3%>=256 &; if %goback%==Y && endlocal && set "message=Abort MEAN: sectors of (md)-device in '%md%' above 255" && set result= && goto :eof ! endlocal && set "message=Abort MEAN: sectors of (md)-device in '%md%' above 255" && set result= && goto :calcfpend
call :sum goback md %md% &; if exist result && set sum=%result% && set result= ! if %goback%==Y && endlocal && set result= && set "message=%message%" && goto :eof ! endlocal && set result= && set "message=%message%" && goto :calcfpend
call :count goback md %md% &; if exist result && call :/ / %sum% "%result%" ! if %goback%==Y && endlocal && set "message=%message%" && set result= && goto :eof ! endlocal && set result= && set "message=%message%" && goto :calcfpend
if not exist result &; if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! endlocal && set "message=%message%" && goto :calcfpend
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :calcfploop
if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfprestart
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if %goback%==Y && endlocal && set result=%result% && set "message=%message%" && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set "message=%message%" && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfpend
:meanloop
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; call :/ / "%result%" %count% &; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; call :/ / "%result%" %count% &; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :calcfploop
if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; call :/ / "%result%" %count% &; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :calcfprestart
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; call :/ / "%result%" %count% &; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="" && set N1=%~1 &; if /i %N1:~-2,2%==mr && set N1=%N1:~0,-2%%%MR% && set lastrnd=%memrnd%
if not "%~1"=="" && call :+ + "%result%" %N1% &; if exist result && set /a count=%count%+1 && shift && goto :meanloop ! endlocal && set "message=%message%" && set result= && goto :eof
call :/ / "%result%" %count%
if %goback%==Y && endlocal && set "message=%message%" && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof
endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && set "message=%message%"
goto :calcfpend
::
:product
#-#+ PRODUCT \tFunction PRODUCT  - Product of numbers behind
#-#  Use 1\tCALCD.G4B PRODUCT number1 number2 [number3 ...]\nUse 2\tCALCD.G4B PRODUCT [MD] FILE\nRemarks Prefix function, result can be used as input to infix or postfix\n\tfunctions. New prefix function restarts calculation\n\tFILE must be an md-device containing numbers only, max 255 sectors\n\tSeparators in FILE: spaces (20), 0A or 0D0A - MD optional\nExample CALCD.G4B PRODUCT 1 2 3 4 5 6\nExample CALCD.G4B PRODUCT 1 2 3 4 5 6 * 7\nExample CALCD.G4B PRODUCT 1! 2! 3! 4! 5! 6!\nExample CALCD.G4B 5! MS PRODUCT 1! 2! 3! 4! MR 6! 7! / 8! THSEP\nExample CALCD.G4B PRODUCT 1 2 3 4 5 6 MSPRODUCT 7 8 9 10*MR\nMake FILE: echo 0.5 1.5 2.5 3.5 4.5 5.5 0.05\x20>\x20(md)0x3000+255\nExample CALCD.G4B PRODUCT (md)0x3000+255\nExample CALCD.G4B PRODUCT (md)0x3000+255 ^ 2\nExample CALCD.G4B PRODUCT (md)0x3000+255 MS 20! / MR
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if %~1==goback && set goback=Y
if "%~3"=="" &; if %goback%==Y && endlocal && set "message=Abort: argument(s) missing in PRODUCT" && goto :eof ! endlocal && set "message=Abort: argument(s) missing in PRODUCT" && goto :calcfpend
shift
if /i %~1==md &; if %~d2==(md) && set md=%~2 && shift && shift ! if %goback%==Y && endlocal && set "message=Abort PRODUCT: (md)-device in '%~2' not found" && set result= && goto :eof ! endlocal && set "message=Abort PRODUCT: (md)-device in '%~2' not found" && set result= && goto :calcfpend
if %~d1==(md) && set md=%~1 && shift
if exist md &; call Fn.11 "%md%" "+" |; if %goback%==Y && endlocal && set "message=Abort PRODUCT: (md)-device in '%md%' not valid" && set result= && goto :eof ! endlocal && set "message=Abort PRODUCT: (md)-device in '%md%' not valid" && set result= && goto :calcfpend
if exist md && if %md:~-3,3%>=256 &; if %goback%==Y && endlocal && set "message=Abort PRODUCT: sectors of (md)-device in '%md%' above 255" && set result= && goto :eof ! endlocal && set "message=Abort PRODUCT: sectors of (md)-device in '%md%' above 255" && set result= && goto :calcfpend
if not exist md && set N1=%~1 &; if /i %N1:~-2,2%==mr && set N1=%N1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %N1%==r && set N1=%R% ! if /i %N1%==-r && set N1=-%R%
if not exist md && set N2=%~2 &; if /i %N2:~-2,2%==mr && set N2=%N2:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %N2%==r && set N2=%R% ! if /i %N2%==-r && set N2=-%R%
if not exist md && call :* * %N1% %N2% &; if exist result && if not "%~3"=="" && shift && shift && goto :productloop ! if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && goto :eof ! endlocal && set "message=%message%" && set result=%result% && goto :calcfpend
cat %md% | call :productloop  &; if exist result && if "%~1"=="" && endlocal && set result=%result% && goto :calcfpend ! if not exist result && endlocal && set "message=%message%" && set result= && goto :calcfpend
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :calcfploop
if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfprestart
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if %goback%==Y && endlocal && set result=%result% && set "message=%message%" && goto :eof ! endlocal && set result=%result% && set "message=%message%" && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfpend
:productloop
if exist md && if "%~1"=="" && goto :eof
if exist md && if exist result && call :* * "%result%" %~1 &; if not exist result && goto :eof
if exist md && if not exist result && call :* * %~1 %~2 &; shift && if not exist result && goto :eof
if exist md && shift && goto :productloop
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfprestart
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="" && set N1=%~1 &; if /i %N1:~-2,2%==mr && set N1=%N1:~0,-2%%%MR% && set lastrnd=%memrnd%
if not "%~1"=="" && call :* * "%result%" %N1% &; if exist result && shift ! endlocal && set "message=%message%" && set result= && goto :calcfpend
if not "%~1"=="" && goto :productloop
if %goback%==Y && endlocal && set "message=%message%" && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof
endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd%
goto :calcfpend
::
:fact
#-#+ FACT \tFunction FACT - Factorial of number behind
#-# Use \tCALCD.G4B FACT n\nRemarks Prefix function, result can be used as input to infix or postfix\n\tfunctions. New prefix function restarts calculation\n\tRange of integer n: from 0 up to 20 (highest result 20!)\nExample CALCD.G4B FACT 5\nExample CALCD.G4B FACT 8 / 7!\nExample CALCD.G4B 1+1MSFACT2INV+MR
setlocal && set * && set MR=%MR% && set R=%R%
if %~1==goback && set goback=Y
if "%~2"=="" &; if %goback%==Y && endlocal && set "message=Abort: argument 'number' is missing in FACT" && goto :eof ! endlocal && set "message=Abort: argument 'number' is missing in FACT" && goto :calcfpend
shift
set "ARG=%~1"
set number1=%~n1 && set decimal1=%~x1 && shift
if /i "%number1:~-1,1%"=="!" && set number1=%number1:~0,-1%
call Fn.11 "%ARG%" "pi" && set number1=3 && set decimal1=.14 ! call Fn.11 "%ARG%" "en" && set number1=2 && set decimal1=.72
if exist decimal1 &; if %goback%==Y && endlocal && set "message=Abort FACT: no decimals allowed in factorials, check '%ARG%'" && goto :eof ! endlocal && set "message=Abort FACT: no decimals allowed in factorials, check '%ARG%'" && goto :calcfpend
if /i "%number1:~-2,2%"=="MR" && set number1=%MR% ! if /i "%number1%"=="R" && set number1=%R% ! if /i "%number1%"=="-R" && set number1=-%R%
call Fn.11 "%number1%" "." &; if %goback%==Y && endlocal && set "message=Abort FACT: no decimals allowed in factorials, check '%number1%'" && goto :eof ! endlocal && set "message=Abort FACT: no decimals allowed in factorials, check '%number1%'" && goto :calcfpend
if "%number1:~0,1%"=="+" && set number1=%number1:~1% && set sign=
if "%number1:~0,1%"=="-" && set number1=%number1:~1% && set "sign=-"
if /i "%number1:~-1,1%"=="!" && set number1=%number1:~0,-1%
if not exist number1 &; if %goback%==Y && endlocal && set "message=Abort FACT: number '%ARG%' is not valid" && set result= && goto :eof ! endlocal && set "message=Abort FACT: number '%ARG%' is not valid" && set result= && goto :calcfpend
if %number1%>=21 &; if %goback%==Y && endlocal && set "message=Abort FACT: factorial of '%number1%!' is too high" && set result= && goto :eof ! endlocal && set "message=Abort FACT: factorial of '%number1%!' is too high" && set result= && goto :calcfpend
if not %number1%==0 if not %number1%==1 || set result=1 ! set n=%number1%
if not %result%==1 &; if %n%==2 && set fac1=2 ! if %n%==3 && set fac1=6 ! if %n%==4 && set fac1=24 ! if %n%==5 && set fac1=120 ! if %n%==6 && set fac1=720 ! if %n%==7 && set fac1=5040 ! if %n%==8 && set fac1=40320 ! if %n%==9 && set fac1=362880 ! if %n%==10 && set fac1=3628800 ! if %n%==11 && set fac1=39916800 ! if %n%==12 && set fac1=479001600 ! if %n%==13 && set fac1=6227020800 ! if %n%==14 && set fac1=87178291200 ! if %n%==15 && set fac1=1307674368000 ! if %n%==16 && set fac1=20922789888000 ! if %n%==17 && set fac1=355687428096000 ! if %n%==18 && set fac1=6402373705728000 ! if %n%==19 && set fac1=121645100408832000 ! if %n%==20 && set fac1=2432902008176640000 &; set result=%fac1%
if %goback%==Y && endlocal && set "message=%message%" && set result=%sign%%%result% && goto :eof
endlocal && set result=%sign%%%result% && set "message=%message%"
goto :calcfploop
::
:inv
#-#+ INV \tFunction INV - Decimal inverse of number before
#-# Use\tCALCD.G4B number INV\nRemarks\tPostfix function, existing result can be used instead of number\n\tInternally 56 digits, 19th decimal is used for rounding\n\tHighest number: 922,337,203,685,477,580 or 0xCCCCCCCCCCCCCCC\nExample CALCD.G4B 10 INV\nExample CALCD.G4B 0.2555 INV\nExample CALCD.G4B -2050.456 INV\nExample CALCD.G4B -2,050.456 INV\nExample CALCD.G4B 0.000000000123456789 INV\nExample CALCD.G4B 0.000000000123456789 INV THSEP\nExample CALCD.G4B 256 INV\nExample CALCD.G4B 256 inv SQRT ^ 2 INV\nExample CALCD.G4B 3! INV\nExample CALCD.G4B 20! INV\nExample CALCD.G4B 1MS 1!INVMP 2!INVMP 3!INVMP 4!INVMP\n\t 5!INVMP 6!INVMP 7!INVMP 8!INVMP 9!INVMP 10!INVMP 11!INVMP\n\t12!INVMP 13!INVMP 14!INVMP 15!INVMP 16!INVMP 17!INVMP\n\t18!INVMP 19!INVMP MRROUND16
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~2"=="" && set "message=Abort: number is missing in INV" && goto :endlocal
shift
set N=%~1
call :/ / 1 %N% &; if exist result && shift ! set rounded= && goto :endlocal
goto :endlocal
::
:sq
#-#+ SQ \tFunction SQ - Number before is raised to power of two
#-# Use\tCALCD.G4B number SQ\nRemarks\tPostfix function, existing result can be used instead of number\n\tInternally 73 digits, 19th decimal is used for rounding\nExample CALCD.G4B 10 SQ\nExample CALCD.G4B 0.2555 SQ\nExample CALCD.G4B -2050.456 SQ\nExample CALCD.G4B -2,050.456 SQ THSEP\nExample CALCD.G4B 256 SQ\nExample set * ;; CALCD.G4B --echoR 256INVSQRTINVSQ
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~2"=="" && set "message=Abort: number is missing in %0" && goto :endlocal
shift
set N=%~1
call :^ ^ %N% 2 &; if exist result && shift ! goto :endlocal
goto :endlocal
::
:cb
#-#+ CB \tFunction CB - Number before is raised to power of three
#-# Use\tCALCD.G4B number CB\nRemarks\tPostfix function, existing result can be used instead of number\n\tInternally 73 digits, 19th decimal is used for rounding\nExample CALCD.G4B 10 CB\nExample CALCD.G4B 0.2555 CB\nExample CALCD.G4B -2050.456 CB\nExample CALCD.G4B -2,050.456 CB THSEP\nExample CALCD.G4B 256 CB\nExample CALCD.G4B --echoR 256INVCBRTINVCBDIGI-4
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~2"=="" && set "message=Abort: number is missing in %0" && goto :endlocal
shift
set N=%~1
call :^ ^ %N% 3 &; if exist result && shift ! goto :endlocal
goto :endlocal
::
:varp
#-#+ VARP \tFunction VARP - Population Variance of numbers behind
#-#  Use 1\tCALCD.G4B VARP number1 number2 [number3 ...]\nUse 2\tCALCD.G4B VARP [MD] FILE\nRemarks Prefix function, result can be used as input to infix or postfix\n\tfunctions. New prefix function restarts calculation\n\tFILE must be an md-device containing numbers only, max 255 sectors\n\tSeparators in FILE: spaces (20), 0A or 0D0A - MD optional\nExample CALCD.G4B VARP 1 2 3\nExample CALCD.G4B 1 - 2 SQ MS 2 - 2 SQ MP 3 - 2 SQ MP COUNT 1 2 3 \\\\ INV * MR\nExample CALCD.G4B VARP 1 2 3 4 5 6 7\nExample CALCD.G4B VARP 1 2 3 4 5 6 7*7DIGI-1\nExample CALCD.G4B VARP (md)0x3000+255\nExample CALCD.G4B VARP (md)0x3000+255 * 3
if "%~3"=="" && set "message=Abort: argument(s) missing in VARP" && goto :calcfpend
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
set /u function=%~1
shift
goto :variation
::
:vars
#-#+ VARS \tFunction VARS - Sample Variance of numbers behind
#-#  Use 1\tCALCD.G4B VARS number1 number2 [number3 ...]\nUse 2\tCALCD.G4B VARS [MD] FILE\nRemarks Prefix function, result can be used as input to infix or postfix\n\tfunctions. New prefix function restarts calculation\n\tFILE must be an md-device containing numbers only, max 255 sectors\n\tSeparators in FILE: spaces (20), 0A or 0D0A - MD optional\nExample CALCD.G4B VARS 1 2 3\nExample CALCD.G4B VARS 1 2 3 * 2\nMake FILE: echo 0.5 1.5 2.5 3.5 4.5 5.5 0.05\x20>\x20(md)0x3000+255\nExample CALCD.G4B VARS (md)0x3000+255\nExample CALCD.G4B VARS (md)0x3000+255SQRT
if "%~3"=="" && set "message=Abort: argument(s) missing in VARS" && goto :calcfpend
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
set /u function=%~1
shift
goto :variation
::
:stdevp
#-#+ STDEVP \tFunction STDEVP - Population Standard Deviation of numbers behind
#-#  Use 1\tCALCD.G4B STDEVP number1 number2 [number3 ...]\nUse 2\tCALCD.G4B STDEVP [MD] FILE\nRemarks Prefix function, result can be used as input to infix or postfix\n\tfunctions. New prefix function restarts calculation\n\tFILE must be an md-device containing numbers only, max 255 sectors\n\tSeparators in FILE: spaces (20), 0A or 0D0A - MD optional\nExample CALCD.G4B STDEVP 1 3 6 10\nExample CALCD.G4B STDEVP 1 3 6 10 SQDIGI-1\nMake FILE: echo 0.5 1.5 2.5 3.5 4.5 5.5 0.05\x20>\x20(md)0x3000+255\nExample CALCD.G4B STDEVP (md)0x3000+255\nExample CALCD.G4B STDEVP (md)0x3000+255 / 100
if "%~3"=="" && set "message=Abort: argument(s) missing in STDEVP" && goto :calcfpend
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
set /u function=%~1
shift
goto :variation
::
:stdevs
#-#+ STDEVS \tFunction STDEVS - Sample Standard Deviation of numbers behind
#-#  Use 1\tCALCD.G4B STDEVS number1 number2 [number3 ...]\nUse 2\tCALCD.G4B STDEVS [MD] FILE\nRemarks Prefix function, result can be used as input to infix or postfix\n\tfunctions. New prefix function restarts calculation\n\tFILE must be an md-device containing numbers only, max 255 sectors\n\tSeparators in FILE: spaces (20), 0A or 0D0A - MD optional\nExample CALCD.G4B STDEVS 1 2 3\nExample CALCD.G4B STDEVS 1 2 3^2\nMake FILE: echo 0.5 1.5 2.5 3.5 4.5 5.5 0.05\x20>\x20(md)0x3000+255\nExample CALCD.G4B STDEVS (md)0x3000+255\nExample CALCD.G4B STDEVS (md)0x3000+255 INV
if "%~3"=="" && set "message=Abort: argument(s) missing in STDEVS" && goto :calcfpend
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
set /u function=%~1
shift
goto :variation
::
:variation
if /i %~1==md &; if %~d2==(md) && set md=%~2 && shift && shift ! endlocal && set "message=Abort '%function%': (md)-device in '%~2' not found" && set result= && goto :calcfpend
if %~d1==(md) && set md=%~1 && shift
if exist md && call Fn.11 "%md%" "+" || endlocal && set "message=Abort '%function%': (md)-device in '%md%' not valid" && set result= && goto :calcfpend
if exist md && if %md:~-3,3%>=256 &; endlocal && set "message=Abort '%function%': sectors of (md)-device in '%md%' above 255" && set result= && goto :calcfpend
set sum=0 && set count=0
if exist md && call :mean goback md %md% &; set mean=%result% && set result= && cat %md% | call :variationloop  &; if exist sum && if %count%>=2 && goto :variationcalculation ! endlocal && set "message=%message%" && set result= && goto :calcfpend
if not exist md && call :mean goback %* &; if exist result && set mean=%result% && set result= && set goback= ! endlocal && set "message=%message%" && set result= && goto :calcfpend
:variationloop
if "%~1"=="" &; if not exist md && goto :variationcalculation ! goto :eof
if not exist md &; if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; goto :variationcalculation
if not exist md &; if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; goto :variationcalculation
if not exist md &; if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; goto :variationcalculation
if not exist md &; if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; goto :variationcalculation
if not "%~1"=="" && set N=%~1 &; if %N:~-2,2%==mr && set N=%N:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %N%==r && set N=%R% ! if /i %N%==-r && set N=-%R%
set difrence= && call :- - %N% %mean% &; if exist result && set difrence=%result% && set result= ! if exist md && goto :eof ! endlocal && set "message=%message%" && set result= && goto :calcfpend
set square= && if exist difrence && call :^ ^ %difrence% 2 &; if exist result && set square=%result% && set result= ! if exist md && goto :calcfpend ! endlocal && set "message=%message%" && set result= && goto :calcfpend
if exist square && call :+ + %sum% %square% &; if exist result && set sum=%result% && set result= ! if exist md && goto :calcfpend ! endlocal && set "message=%message%" && set result= && goto :calcfpend
set /a count=%count%+1 && shift
set N=
goto :variationloop
:variationcalculation
debug msg=0
if %function%==VARP && if %count%>=2 && call :/ / %sum% %count% &; if not exist result && endlocal && set result= && goto :calcfpend
if %function%==VARS && set /a count=%count%-1 &; if %count%>=1 && call :/ / %sum% %count% &; if not exist result && endlocal && set "message=%message%" && set result= && goto :calcfpend
if %function%==STDEVP && if %count%>=2 && call :/ / %sum% %count% &; if not exist result && endlocal && set "message=%message%" && set result= && goto :calcfpend
if %function%==STDEVP && if %count%>=2 && call :sqrt sqrt "%result%" &; if not exist result && endlocal && set "message=%message%" && set result= && goto :calcfpend
if %function%==STDEVS && set /a count=%count%-1 &; if %count%>=1 && call :/ / %sum% %count% &; if not exist result && endlocal && set "message=%message%" &&  set result= && goto :calcfpend
if %function%==STDEVS && if %count%>=1 && call :sqrt sqrt "%result%" &; if not exist result && endlocal && set "message=%message%" && set result= && goto :calcfpend
if %function:~-1,1%==P && if not exist result && endlocal && set result= && goto :calcfpend
if %function:~-1,1%==S && if not exist result && endlocal && set result= && goto :calcfpend
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfprestart
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && set "message=%message%"
goto :calcfpend
::
:"=="
#-#+ == \tFunction "==" - Compare if number1 and number2 are equal
#-# Use \tCALCD.G4B "==" number1 number2\nRemarks If number1==number2 - result=1, if not result=0\n\tDouble qoutes AND spaces around mandatory in "=="\nExample CALCD.G4B "==" 1 1\nExample CALCD.G4B "==" 1 0\nExample CALCD.G4B "==" 1.1 1.20000000\nExample CALCD.G4B "==" -1 -1\nExample CALCD.G4B "==" -.2 -.20000000\nExample CALCD.G4B 8! MS "==" MR 7!\nExample CALCD.G4B "==" 0x1000 0x1000.0001\nExample CALCD.G4B "==" 1,000 1000\nExample CALCD.G4B "==" 2.11 1.11\x20;;\x20if %result%==1\x20&&\x20CALCD.G4B 2.11 + 1.11\n\t\t  \x20!\x20CALCD.G4B 2.11 - 1.11
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R%
if "%~3"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
shift
set n1=%~1 &; if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
set n2=%~2 &; if /i %n2:~-2,2%==mr && set n2=%n2:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n2%==r && set n2=%R% ! if /i %n2%==-r && set n2=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
if /i "%n2:~-1,1%"=="!" && set n2=%n2:~0,-1% &; if %n2:~0,1%==- && set n2=%n2:~1% && set sign=- ! set sign= &; call :fact goback %n2% &; if exist result && set n2=%sign%%%result% && set result= ! set rounded= && goto :endlocal
call :operatorsinput %0 "%n1%" "%n2%" &; if exist message && goto :endlocal
if not exist N1 && set N1=0 ;; if not exist N2 && set N2=0
if %N1%==%N2% && set result=1 ! set result=0
if not %result%==0 &; if not exist decimal1 if not exist decimal2 |; if %decimal1%==%decimal2% && set result=1 ! set result=0
if not %result%==0 && if not exist decimal1 && if not exist decimal2 && set result=1
if not %sign1%==%sign2% && set result=0
endlocal && set result=%result%
goto :eof
::
:">="
#-#+ >= \tFunction ">=" - Compare if number1 is greater or equal than number2
#-# Use \tCALCD.G4B ">=" number1 number2\nRemarks If number1>=number2 - result=1, if not result=0\n\tDouble qoutes AND spaces around mandatory in ">="\nExample CALCD.G4B ">=" 1 1\nExample CALCD.G4B ">=" 1 0\nExample CALCD.G4B ">=" 1.2 1.10000000\nExample CALCD.G4B ">=" -1 -1\nExample CALCD.G4B ">=" -.1 -.20000000\nExample CALCD.G4B 8! MS ">=" MR 7!\nExample CALCD.G4B ">=" 0x1000 0x1000.0001\nExample CALCD.G4B ">=" 1,001 1000\nExample CALCD.G4B ">=" 2.11 1.11\x20;;\x20if %result%==1\x20&&\x20CALCD.G4B 2.11 + 1.11\n\t\t  \x20!\x20CALCD.G4B 2.11 - 1.11
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R%
if "%~3"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
shift
set n1=%~1 &; if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
set n2=%~2 &; if /i %n2:~-2,2%==mr && set n2=%n2:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n2%==r && set n2=%R% ! if /i %n2%==-r && set n2=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
if /i "%n2:~-1,1%"=="!" && set n2=%n2:~0,-1% &; if %n2:~0,1%==- && set n2=%n2:~1% && set sign=- ! set sign= &; call :fact goback %n2% &; if exist result && set n2=%sign%%%result% && set result= ! set rounded= && goto :endlocal
call :operatorsinput %0 "%n1%" "%n2%" &; if exist message && goto :endlocal
if not exist N1 && set N1=0 ;; if not exist N2 && set N2=0
set /a N1=%sign1% * %N1% && set /a N2=%sign2% * %N2%
if not %N1%<=%N2% && set greater=1 ! set greater=0
if %greater%==0 && if %N1%==%N2% &; if not %numdeci1%>=%numdeci2% && call :addzerosafter "%numdeci1%" "%numdeci2%" "%decimal1%" &; set decimal1=%result% && set result=
if %greater%==0 && if %N1%==%N2% &; if not %numdeci2%>=%numdeci1% && call :addzerosafter "%numdeci2%" "%numdeci1%" "%decimal2%" &; set decimal2=%result% && set result=
if %greater%==0 && if %N1%==%N2% &; if not exist decimal1 if not exist decimal2 |; set /a decimal1=%sign1% * %decimal1% && set /a decimal2=%sign2% * %decimal2% &; if %decimal1%>=%decimal2% && set greater=1 ! set greater=0
if %greater%==0 && if %N1%==%N2% && if not exist decimal1 && if not exist decimal2 && set greater=1
if %greater%==1 && set result=1 ! set result=0
endlocal && set result=%result%
goto :eof
::
:"<="
#-#+ <= \tFunction "<=" - Compare if number1 is smaller or equal than number2
#-#  Use \tCALCD.G4B "<=" number1 number2\nRemarks If number1<=number2 - result=1, if not result=0\n\tDouble qoutes AND spaces around mandatory in "<="\nExample CALCD.G4B "<=" 1 1\nExample CALCD.G4B "<=" 1 0\nExample CALCD.G4B "<=" 1.1 1.20000000\nExample CALCD.G4B "<=" -1 -1\nExample CALCD.G4B "<=" -.1 -.20000000\nExample CALCD.G4B 8! MS "<=" MR 7!\nExample CALCD.G4B "<=" 0x1000 0x1000.0001\nExample CALCD.G4B "<=" 1,001 1000\nExample CALCD.G4B "<=" 2.11 1.11\x20;;\x20if %result%==1\x20&&\x20CALCD.G4B 2.11 + 1.11\n\t\t  \x20!\x20CALCD.G4B 2.11 - 1.11
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R%
if "%~3"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
shift
set n1=%~1 &; if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
set n2=%~2 &; if /i %n2:~-2,2%==mr && set n2=%n2:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n2%==r && set n2=%R% ! if /i %n2%==-r && set n2=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
if /i "%n2:~-1,1%"=="!" && set n2=%n2:~0,-1% &; if %n2:~0,1%==- && set n2=%n2:~1% && set sign=- ! set sign= &; call :fact goback %n2% &; if exist result && set n2=%sign%%%result% && set result= ! set rounded= && goto :endlocal
call :operatorsinput %0 "%n1%" "%n2%" &; if exist message && goto :endlocal
if not exist N1 && set N1=0 ;; if not exist N2 && set N2=0
set /a N1=%sign1% * %N1% && set /a N2=%sign2% * %N2%
if not %N1%>=%N2% && set smaller=1 ! set smaller=0
if %smaller%==0 && if %N1%==%N2% &; if not %numdeci1%>=%numdeci2% && call :addzerosafter "%numdeci1%" "%numdeci2%" "%decimal1%" &; set decimal1=%result% && set result=
if %smaller%==0 && if %N1%==%N2% &; if not %numdeci2%>=%numdeci1% && call :addzerosafter "%numdeci2%" "%numdeci1%" "%decimal2%" &; set decimal2=%result% && set result=
if %smaller%==0 && if %N1%==%N2% &; if not exist decimal1 if not exist decimal2 |; set /a decimal1=%sign1% * %decimal1% && set /a decimal2=%sign2% * %decimal2% &; if %decimal1%<=%decimal2% && set smaller=1 ! set smaller=0
if %smaller%==0 && if %N1%==%N2% && if not exist decimal1 && if not exist decimal2 && set smaller=1
if %smaller%==1 && set result=1 ! set result=0
endlocal && set result=%result%
goto :eof
::
:Pnr
#-#+ Pnr \tFunction Pnr - Permutations of n objects taken r at a time
#-# Use \tCALCD.G4B Pnr n r\nRemarks Prefix function, result can be used as input to infix or postfix\n\tfunctions. New prefix function restarts calculation\n\tRange of integers: n, r from 1 up to 20 and r <= n\nExample CALCD.G4B Pnr 7 3\nExample CALCD.G4B 7 - 3 MS 7! / MR!\nExample CALCD.G4B 7! MS 7 - 3 SRM / MR!\nExample CALCD.G4B Pnr 5 5 MSPnr 4 4 MPMR\nExample CALCD.G4B Pnr 5 5\nExample CALCD.G4B 5! MS MR\nExample CALCD.G4B 5! MS MR * 1\nExample CALCD.G4B 5! * 1
if not "%~2"=="" if not "%~3"=="" || set "message=Abort: argument(s) number missing in Pnr, check '%~1' or '%~2'" && goto :calcfpend
shift
setlocal && set * && set MR=%MR% && set R=%R%
set n=%~n1
#ORG#set n=%~n1 && shift
if /i %n:~-2,2%==mr && set n=%n:~0,-2%%%MR% ! if /i %n%==r && set n=%R% ! if /i %n%==-r && set n=-%R%
if "%n:~0,1%"=="-" && set n=%n:~1%
if "%n:~0,1%"=="+" && set n=%n:~1%
if "%n:~-1,1%"=="!" && set n=%n:~0,-1%
call Fn.11 "%n%" "pi" && set n= ! call Fn.11 "%n%" "en" && set n=
if not exist n && endlocal && set "message=Abort Pnr: number '%~1' is not valid" && set result= && goto :calcfpend ! shift
if %n%==0 && endlocal && set "message=Abort Pnr: n=0 is not possible" && set result= && goto :calcfpend
if %n%>=21 && endlocal && set "message=Abort Pnr: factorial of '%n%!' is too high" && set result= && goto :calcfpend
set r=%~n1
if /i %r:~-2,2%==mr && set r=%r:~0,-2%%%MR% ! if /i %r%==r && set r=%R% ! if /i %r%==-r && set r=-%R%
if "%r:~0,1%"=="-" && set r=%r:~1%
if "%r:~0,1%"=="+" && set r=%r:~1%
if "%r:~-1,1%"=="!" && set r=%r:~0,-1%
call Fn.11 "%r%" "pi" && set r= ! call Fn.11 "%r%" "en" && set r=
if not exist r && endlocal && set "message=Abort Pnr: number '%~1' is not valid" && set result= && goto :calcfpend ! shift
if %r%==0 && endlocal && set "message=Abort Pnr: r=0 is not possible" && set result= && goto :calcfpend
if %r%>=21 && endlocal && set "message=Abort Pnr: factorial of '%r%!' is too high" && set result= && goto :calcfpend
if not %r%<=%n% && endlocal && set "message=Abort Pnr: '%r%' > '%n%'" && set result= && goto :calcfpend
calc %n% - %r% ;; set /a P=%@retval%
call :fact goback %n% &; if not exist message && set n=%result% && set result= ! endlocal && set "message=%message%" && set result= && goto :calcfpend
call :fact goback %P% &; if not exist message && set P=%result% && set result= ! endlocal && set "message=%message%" && set result= && goto :calcfpend
set /a result=%n% / %P%
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; endlocal && set result=%result% && goto :calcfploop
if not "%~2"=="" &; if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; endlocal && set result=%result% && goto :calcfploop
if not "%~2"=="" && if not "%~3"=="" &; if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" |; endlocal && set result=%result% && goto :calcfprestart
endlocal && set result=%result%
goto :calcfpend
::
:Cnr
#-#+ Cnr \tFunction Cnr - Combinations of n objects taken r at a time
#-# Use \tCALCD.G4B Cnr n r\nRemarks Prefix function, result can be used as input to infix or postfix\n\tfunctions. New prefix function restarts calculation\n\tRange of integers: n, r from 1 up to 20 and r <= n\nExample CALCD.G4B Cnr 7 3\nExample CALCD.G4B 7 - 3 MS 7! / MR! / 3!\nExample CALCD.G4B 7! MS 7 - 3 SRM / MR! / 3!\nExample CALCD.G4B Cnr 7 3/2.5MS Cnr 7 3 MPMR\nExample CALCD.G4B MC Cnr 5 1 MP Cnr 5 2 MP Cnr 5 3 MP Cnr 5 4 MP Cnr 5 5 MP MR
if not "%~2"=="" if not "%~3"=="" || set "message=Abort: argument(s) number missing in Cnr, check '%~1' or '%~2'" && goto :calcfpend
shift
setlocal && set * && set MR=%MR% && set R=%R%
set n=%~n1
if /i %n:~-2,2%==mr && set n=%n:~0,-2%%%MR% ! if /i %n%==r && set n=%R% ! if /i %n%==-r && set n=-%R%
if "%n:~0,1%"=="-" && set n=%n:~1%
if "%n:~0,1%"=="+" && set n=%n:~1%
if "%n:~-1,1%"=="!" && set n=%n:~0,-1%
call Fn.11 "%n%" "pi" && set n= ! call Fn.11 "%n%" "en" && set n=
if not exist n && endlocal && set "message=Abort Cnr: number '%~1' is not valid" && set result= && goto :calcfpend ! shift
if %n%==0 && endlocal && set "message=Abort Cnr: n=0 is not possible" && set result= && goto :calcfpend
if %n%>=21 && endlocal && set "message=Abort Cnr: factorial of '%n%!' is too high" && set result= && goto :calcfpend
set r=%~n1
if /i %r:~-2,2%==mr && set r=%r:~0,-2%%%MR% ! if /i %r%==r && set r=%R% ! if /i %r%==-r && set r=-%R%
if "%r:~0,1%"=="-" && set r=%r:~1%
if "%r:~0,1%"=="+" && set r=%r:~1%
if "%r:~-1,1%"=="!" && set r=%r:~0,-1%
call Fn.11 "%r%" "pi" && set r= ! call Fn.11 "%r%" "en" && set r=
if not exist r && endlocal && set "message=Abort Cnr: number '%~1' is not valid" && set result= && goto :calcfpend ! shift
if %r%==0 && endlocal && set "message=Abort Cnr: r=0 is not possible" && set result= && goto :calcfpend
if %r%>=21 && endlocal && set "message=Abort Cnr: factorial of '%r%!' is too high" && set result= && goto :calcfpend
if not %r%<=%n% && endlocal && set "message=Abort Cnr: '%r%' > '%n%'" && set result= && goto :calcfpend
calc %n% - %r% ;; set /a P=%@retval%
call :fact goback %n% &; if not exist message && set n=%result% && set result= ! endlocal && set "message=%message%" && set result= && goto :calcfpend
call :fact goback %P% &; if not exist message && set P=%result% && set result= ! endlocal && set "message=%message%" && set result= && goto :calcfpend
call :fact goback %r% &; if not exist message && set r=%result% && set result= ! endlocal && set "message=%message%" && set result= && goto :calcfpend
set /a result=%n% / %P% / %r%
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; endlocal && set result=%result% && goto :calcfploop
if not "%~2"=="" &; if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; endlocal && set result=%result% && goto :calcfploop
if not "%~2"=="" && if not "%~3"=="" &; if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" |; endlocal && set result=%result% && goto :calcfprestart
endlocal && set result=%result%
goto :calcfpend
::
:round
#-#+ ROUND \tFunction ROUND - Number before is rounded to given number of\n\tdecimals or integers
#-# Use\tCALCD2.G4B [switch] number1 ROUND NUMBER\nRemarks Infix function, existing result can be used instead of number1\n\tRounding up in earlier result is undone first: no double rounding\n\tIf highest lost digit >=5 rounding up, if <=4 rounding down\n\tIf NUMBER >=0 rounding of decimals, if NUMBER <=-1 rounding of integers\n\tIf variable 'round' is set before use of CALCD.G4B, result is rounded\n\tUsing ROUND last on command-line overides set-variable 'round'\n\tIf variable 'deci' exists too, 'deci' is first, 'fix' overides 'round'\n\tIf 'digi' exists too and if 'rounded=Y', 'round' will be ignored\n\tSet-variable 'round' is case-sensitive!\nExample CALCD.G4B 0.12345 ROUND 4\nExample CALCD.G4B 10 / 7 ROUND 4 * 7\nExample CALCD.G4B STDEVP 1 2 3 4 5 6 7 ROUND 8\nExample CALCD.G4B 12345 ROUND -4\nExample CALCD.G4B 12345678912345678 SQRT ROUND 0\nExample$[0x00]"$[0x07]set round=0 ;; CALCD.G4B 12345678912345678 SQRT\nExample$[0x00]"$[0x07]set round=0 ;; CALCD.G4B 12345678912345678SQRTROUND2
if "%~4"=="" && set round=
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set echor=%echor% && set echoMR=%echoMR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~3"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
shift
set n1=%~1
if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
set n2=%~2
set fix=Y && call :operatorsinput %0 "%n1%" "%n2%" &; if exist message && goto :endlocal
if %sign1%==-1 && set sign=-
if %lastrnd%==1 && if %numdeci1%>=1 && set /a decidiff=%numdeci1% - %N2% &; if %decidiff%>=1 &; set /a decimal1=%decimal1% - 1 &; set decimal1=000000000000000000%decimal1% &; call set decimal1=%^decimal1:~-%numdeci1%,%numdeci1%%%
if %sign2%==1 && if not exist decimal1 && set result=%n1% && goto :endlocal
if %sign2%==1 && if %N2%>=%numdeci1% && set result=%sign%%%N1%.%decimal1:~0,18% && goto :endlocal
if %sign2%==1 &; call if %^decimal1:~%N2%,1%>=5 && set round=1 && set lastrnd=1 ! set round=0 && set lastrnd=0
if %sign2%==1 && call set decimal1=%^decimal1:~0,%N2%%% && set rounded=Y
if %sign2%==1 && if %N2%>=1 && set round=000000000000000000%round% &; call set round=%^round:~-%N2%,%N2%%%
if %sign2%==1 && if %N2%>=1 &; if not %round%==0 && call :+ + %sign1:~0,-1%%%N1%.%decimal1% %sign1:~0,-1%%0.%round% ! set result=%sign1:~0,-1%%%N1%.%decimal1%
if %sign2%==1 && if %N2%==0 && set /a result=%sign1% * %N1% + %sign1:~0,-1%%%round%
if %sign2%==1 && goto :endlocal
if %N1%>=1 && set N1=%N1% &; set /a N1len=%@retval% &; if %N2%>=%N1len% && set /a N2=%N1len%-1
if %N1%==0 && set result=%n1% && goto :endlocal
call if %^N1:~-%N2%,1%>=5 && set round=1 ! set round=0
call set N1=%^N1:~0,-%N2%%% && set rounded=Y
set N=000000000000000000 &; call set N=%^N:~0,%N2%%% && set rounded=Y
set /a result=%sign1% * %N1% + %sign1:~0,-1%%%round% &; set /a result=%result%%%N%
goto :endlocal
::
:rounddown
#-#+ ROUNDDOWN \tFunction ROUNDDOWN - alias of DECI
:deci
#-#+ DECI \tFunction DECI - Number before is rounded down to given number of\n\tdecimals or integers
#-# Use\tCALCD2.G4B [switch] number1 DECI NUMBER (alias: ROUNDDOWN)\nRemarks Infix function, existing result can be used instead of number1\n\tRounding up in earlier result is undone first (remains with DECI 18)\n\tIf NUMBER >=0 rounddown decimals, ignored if not enough decimals\n\tif NUMBER <=-1 rounddown integers, ignored if not enough integers\n\tIf variable 'deci' is set before CALCD.G4B, result is rounded down\n\tUsing DECI last on command-line overides set-variable 'deci'\n\tIf 'round' exists too, 'deci' is first\n\tIf 'digi' exists too and if 'rounded=Y', 'deci' will be ignored\n\tIf 'fix' exists too, 'deci' will be ignored\n\tSet-variable 'deci' is case-sensitive!\nExample CALCD.G4B 0.12345 DECI 4\nExample CALCD.G4B 10 / 7 DECI 4\nExample CALCD.G4B 10 / 7 DECI 4 * 7\nExample CALCD.G4B STDEVP 1 2 3 4 5 6 7 DECI 8\nExample CALCD.G4B 12345678912345678 SQRT DECI 0\nExample$[0x00]"$[0x07]set deci=0 ;; CALCD.G4B 12345678912345678 SQRT\nExample$[0x00]"$[0x07]set deci=0 ;; CALCD.G4B 12345678912345678SQRTDECI-2
if "%~4"=="" && set deci=
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set echor=%echor% && set echoMR=%echoMR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~3"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
shift
set n1=%~1
if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
set n2=%~2
call :operatorsinput %0 "%n1%" "%n2%" &; if exist message && goto :endlocal
if %sign1%==-1 && set sign=-
if %sign2%==1 && if not exist decimal1 && set result=%n1% && goto :endlocal
if not %N2%<=18 && set result=%n1% && goto :endlocal
if %sign2%==1 && if %lastrnd%==1 && set /a decimal1=%decimal1% - 1 &; set decimal1=000000000000000000%decimal1% &; call set decimal1=%^decimal1:~-%numdeci1%,%numdeci1%%% && set lastrnd=0
if %sign2%==1 && if %N2%>=%numdeci1% && set result=%sign%%%N1%.%decimal1% && goto :endlocal
if %sign2%==1 && call set decimal1=%^decimal1:~0,%N2%%% && set rounded=Y && set lastrnd=0
if %sign2%==1 && set /a integer=%sign1% * %N1%
if %sign2%==1 &; if exist decimal1 && set result=%integer%.%decimal1% && goto :endlocal ! set result=%integer% && goto :endlocal
if %N2%>=%N1len% && set /a N2=%N1len%-1
if %numdeci1%==0 && if %lastrnd%==1 && set /a N1=%N1% - 1
call set N1=%^N1:~0,-%N2%%% && set rounded=Y && set lastrnd=0
set N=000000000000000000 &; call set N=%^N:~0,%N2%%%
set /a result=%sign1% * %N1% &; set /a result=%result%%%N%
goto :endlocal
::
:digi
#-#+ DIGI \tFunction DIGI - Digits in number before rounded to given number
#-# Use\tCALCD2.G4B [switch] number1 DIGI NUMBER\nRemarks Infix function, existing result can be used instead of number1\n\tRounding up in earlier result is undone first: no double rounding\n\tIf highest lost digit >=5 rounding up, if <=4 rounding down\n\tIf NUMBER >= 1 rounding to given number of digits\n\tIf NUMBER <=-1 rounding with less digits (NUMBER = 0 is ignored)\n\tDIGI with NUMBER <=-1 can only be used if 'rounded=Y', check: --echoR\n\tIf variable 'digi' is set before use of CALCD.G4B, digits in result\n\tare limited to value of 'digi'. Use of DIGI on command-line overides\n\tIf 'deci' and / or 'round' exists too, they will be ignored\n\tIf 'fix' exists too, 'fix' overrides 'digi'\n\tSet-variable 'digi' is case-sensitive!\n\tSet-variable 'digi' will only be used if 'rounded=Y', check: --echoR\nExample CALCD.G4B 10.12345 DIGI 4\nExample CALCD.G4B 10 / 7 DIGI 4\nExample CALCD.G4B 10 / 7 DIGI 4 * 7\nExample CALCD.G4B STDEVP 1 2 3 4 5 6 7 DIGI 4\nExample CALCD.G4B 12345678912345678 SQRT DIGI 8\nExample$[0x00]"$[0x07]set digi=9 ;; CALCD.G4B 123456789.123456789 SQRT\nExample set digi=9 ;; CALCD.G4B 123456789.123456789SQRTDIGI-9\nExample$[0x00]"$[0x07]set digi=-9 ;; CALCD.G4B --echoR 1.23 ^ 9 ;; CALCD.G4B --echoR 1.23 ^ 10
#??#\n\tSet-variable 'digi' will only be used if 'rounded=Y'
if "%~4"=="" && set digi=
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set echor=%echor% && set echoMR=%echoMR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~3"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
shift
set n1=%~1
if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
set n2=%~2 &; if %n2%==0 && set result=%n1% && goto :endlocal
call :operatorsinput %0 "%n1%" "%n2%" &; if exist message && goto :endlocal
if %N1%==0 && set N1len=0
if %sign2%==-1 && set sign2=- && goto :lessdigits
if %N2%==0 && set result=%n1% && goto :endlocal
if not %N2%<=37 && set result=%n1% && goto :endlocal
set /a digits=%N1len% + %numdeci1%
set zeros=0000000000000000000000000000000000000
if %sign2%==1 && if not %N2%<=%digits% && set result=%n1% && goto :endlocal
if not %N2%>=%N1len% && set /a digileft=%N2% + 1 && set decimal1= && set numdeci1=0 && set /a numzeros=%N1len% - %N2% &; call set /a N1=%^N1:~0,%digileft%%% &; call if %^N1:~%N2%,1%>=5 && call set /a N1=%^N1:~0,%N2%%% + 1 && set lastrnd=1 ! call set N1=%^N1:~0,%N2%%% && set lastrnd=0
if %N2%>=%N1len% && if %numdeci1%>=1 && set /a N2=%N2% - %N1len% &; if %N2%>=1 && set /a digileft=%N2% + 1 &; call set decimal1=%^decimal1:~0,%digileft%%% &; call if %^decimal1:~%N2%,1%>=5 && set round=1 && set lastrnd=1 && call set decimal1=%^decimal1:~0,%N2%%% ! set round=0 && set lastrnd=0 && call set decimal1=%^decimal1:~0,%N2%%%
if %round%==1 && if %N2%>=1 && set /a decimal1=%decimal1% + 1 &; set decimal1=000000000000000000%decimal1% &; call set /a N1=%N1% + %^decimal1:~0,-%N2%%% && call set decimal1=%^decimal1:~-%N2%,%N2%%%
if exist decimal1 && if %N2%==0 &; if %decimal1:~0,1%>=5 && set /a N1=%N1% + 1 && set lastrnd=1 && set decimal1= ! set decimal1= && set lastrnd=0
if not exist decimal1 && call set zeros=%^zeros:~0,%numzeros%%%
#BadResultIfAllZeros!#if exist decimal1 && call :stripzerosafter "%decimal1%" &; set decimal1=%result% && set result=
if exist decimal1 && set result=%N1%.%decimal1% ! set result=%N1%%%zeros%
if %sign1%==-1 && set result=-%result%
goto :endlocal
::
:lessdigits
if not %rounded%==Y && set result=%~1 && goto :endlocal
set /a numdigi=%N1len% + %numdeci1% &; if %N2%>=%numdigi% && set result=%~1 && goto :endlocal
set digiless=%N2%
if %numdeci1%>=%digiless% && set /a digileft=%numdeci1% - %digiless% &; call :round round %~1 %digileft% &; goto :endlocal
set decimal1= && set /a digileft=%numdeci1% - %digiless%
:lessintegers
call if %^N1:~%digileft%,1%==0 && set /a digileft=%digileft% - 1 && goto :lessintegers
call :round round %sign2%%%N1% %digileft%
goto :endlocal
::
:fix
#-#+ FIX \tFunction FIX - Decimals in number before fixed to given number
#-# Use\tCALCD2.G4B [switch] number1 FIX NUMBER\nRemarks Infix function, existing result can be used instead of number1\n\tRounding up in earlier result is undone first: no double rounding\n\tIf highest lost digit >=5 rounding up, if <=4 rounding down\n\tIf NUMBER >= 0 rounding to given number of decimals\n\tIf NUMBER <=-1 FIX is ignored\n\tIf variable 'fix' is set before, also decimals in last results\n\tare limited to value of 'fix'. Use of FIX on command-line overides\n\tIf 'deci' and/ or 'round' and/ or 'digi' exists, 'fix' overrides\n\tSet-variable 'fix' is case-sensitive!\nExample CALCD.G4B 10.12345 FIX 4\nExample CALCD.G4B 10 / 7 FIX 4\nExample CALCD.G4B 10 / 7 FIX 4 * 7\nExample CALCD.G4B STDEVP 1 2 3 4 5 6 7 FIX 4\nExample CALCD.G4B 12345678912345678SQRTFIX8\nExample$[0x00]"$[0x07]set fix=3 ;; CALCD.G4B 123456789.123456789 SQRT\nExample$[0x00]"$[0x07]set fix=2 ;; CALCD.G4B 123456789.123456789 SQRT FIX 5\nExample$[0x00]"$[0x07]set fix=4 ;; CALCD.G4B 123456789.123456789 SQRT / 7 ;; echo && set
if "%~4"=="" && set fix= && set round= && set deci= && set digi=
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set echor=%echor% && set echoMR=%echoMR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R%
if "%~3"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
shift
set n1=%~1
if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
set n2=%~n2 &; if %n2:~0,1%==- && set sign=- && set n2=%fix:~1% &; if not exist n2 && set result=%n1% && set fixed= && goto :endlocal ! if %sign%==- && set result=%n1% && set fixed= && goto :endlocal
call :operatorsinput %0 "%n1%" "%n2%" &; if exist message && goto :endlocal
if %sign1%==-1 && set sign=-
if %N2%>=18 && set result=%sign%%%N1%.%decimal1:~0,18% && goto :endlocal
call :round round "%N1%.%decimal1%" "%N2%" && if exist result && set fixed=Y ! set rounded= && set lastrnd= && goto :endlocal
call :splitnumber "%result%" &; if %N2%>=1 && set decimals=%decimals%%000000000000000000 &; call set decimals=%^decimals:~0,%N2%%%
if exist decimals && set result=%sign%%%N%.%decimals% ! set result=%sign%%%N%
goto :endlocal
::
:cbrt
#-#+ CBRT \tFunction CBRT - Cubic root of number before
#-# Use\tCALCD.G4B number CBRT\nRemarks\tPostfix function, existing result can be used instead of number\n\tInternally 37 digits, NO rounding\nExample CALCD.G4B 729 CBRT\nExample CALCD.G4B 2.985984 CBRT\nExample CALCD.G4B 1881365963625 CBRT\nExample CALCD.G4B 160288833718161 CBRT\nExample CALCD.G4B -2050.456 CBRT\nExample CALCD.G4B 0.000000019184 CBRT\nExample CALCD.G4B 0x7FFFFFFFFFFFFFFFCBRTHEX\nExample CALCD.G4B --echoR 0x7FFFFFFFFFFFFFFF CBRT ROUND 0 HEX\nExample CALCD.G4B 5,390,793,501,178,682,241.662464 CBRT THSEP\nExample CALCD.G4B --echo 19.184 CBRT MS MR ^ 3 MS DIGI -2 ;; echo && set
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~2"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
shift
set n1=%~1 &; if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
call :operatorsinput %0 "%n1%" &; if exist message && goto :endlocal ! set n1=
if not exist decimal1 && set numdeci1=0
if exist decimal1 && set decimal1=%decimal1:~0,18% &; set /a numdeci1=%@retval%
if %N1%==0 && if %numdeci1%==0 && set result=0 && goto :endlocal
if "%sign1%"=="-1" && set sign=- ! set sign=
set N=%N1% &; set /a Nlen=%@retval% &; if %N%==0 && set Nlen=0
set decilen=0 && set numdeci=0 && set decimals=%decimal1% && set maxdeci=18
:checkleadzeros
if exist decimals && if %N%==0 && if %decimals:~0,3%==0 && set decimals=%decimals:~3% && set /a numdeci=%numdeci%+1 && set enddeci=Y && goto :checkleadzeros
if exist decimals && set decimals=%decimals% &; set /a decilen1=%@retval%
if exist decimals &; if %decilen1%==1 && set decimals=%decimals%%00 ! if %decilen1%==2 && set decimals=%decimals%%0
if exist decimals && set decimal=%decimals% &; set /a decilen=%@retval% && set decimals= &; calc %decilen% % 3 &; if %@retval%==2 && set decimal=%decimal%%0 && set /a decilen=%decilen% + 1 ! set decimal=%decimal%%00 && set /a decilen=%decilen% + 2
if exist decimal && if %N%==0 && set N=%decimal:~0,3% && set decimal=%decimal:~3% && set /a numdeci=%numdeci%+1 && set enddeci=Y
if exist decimal && set N=%N% &; set /a Nlen=%@retval%
calc %Nlen% % 3 |; if %N:~0,3%>=729 && set /a startcrt=%N:~0,3% && set N=%N:~3% && set proxy=729 && set crt=9 ! if %N:~0,3%>=512 && set startcrt=%N:~0,3% && set N=%N:~3% && set proxy=512 && set crt=8 ! if %N:~0,3%>=343 && set startcrt=%N:~0,3% && set N=%N:~3% && set proxy=343 && set crt=7 ! if %N:~0,3%>=216 && set startcrt=%N:~0,3% && set N=%N:~3% && set proxy=216 && set crt=6 ! if %N:~0,3%>=125 && set startcrt=%N:~0,3% && set N=%N:~3% && set proxy=125 && set crt=5 ! if %N:~0,3%>=100 && set startcrt=%N:~0,3% && set N=%N:~3% && set proxy=64 && set crt=4 ! if %N:~0,3%>=64 && set /a startcrt=%N:~0,3% && set N=%N:~3% && set proxy=64 && set crt=4 ! if %N:~0,3%>=27 && set /a startcrt=%N:~0,3% && set N=%N:~3% && set proxy=27 && set crt=3 ! if %N:~0,3%>=8 && set /a startcrt=%N:~0,3% && set N=%N:~3% && set proxy=8 && set crt=2 ! set /a startcrt=%N:~0,3% && set N=%N:~3% && set proxy=1 && set crt=1
if not exist crt && calc %Nlen% % 3 &; if %@retval%==2 &; if %N:~0,2%>=64 && set startcrt=%N:~0,2% && set N=%N:~2% && set proxy=64 && set crt=4 ! if %N:~0,2%>=27 && set startcrt=%N:~0,2% && set N=%N:~2% && set proxy=27 && set crt=3 ! if %N:~0,2%>=8 && set /a startcrt=%N:~0,2% && set N=%N:~2% && set proxy=8 && set crt=2 ! set /a startcrt=%N:~0,2% && set N=%N:~2% && set proxy=1 && set crt=1
if not exist crt && calc %Nlen% % 3 &; if %@retval%==1 &; if %N:~0,1%>=8 && set startcrt=%N:~0,1% && set N=%N:~1% && set proxy=8 && set crt=2 ! set startcrt=%N:~0,1% && set N=%N:~1% && set proxy=1 && set crt=1
set /a remainer=%startcrt% - %proxy%
if not exist N && if %remainer%==0 &; if %numdeci%==0 && if %decilen%==0 && set /a integer=%crt% && goto :calccrtend ! set integer=0 && set decimals=000000000000000000%crt%
if not exist N && if %remainer%==0 && if not exist decimal &; if %numdeci%>=1 && set crt=000000%crt% &; call set /a integer=%^crt:~0,-%numdeci%%% && call set decimals=%^crt:~-%numdeci%,%numdeci%%% && goto :calccrtend
set proxy=
if not exist N && if not exist decimal && set decimal=0000000000000000000000000000000000000000000000000000000 && set end=Y
if not exist N && if exist decimal && set N=%decimal:~0,3% && set decimal=%decimal:~3% && set /a numdeci=%numdeci%+1 && set enddeci=Y
set remainer=%remainer%%%N:~0,3% && set N=%N:~3%
set D=9
:calccrtloop
set /a proxyA=300 * %crt% * %crt%
set /a proxyB=30 * %crt% * %D%
set /a proxy=%D% * %D% + %proxyA% + %proxyB% * %D%
if not %proxy%<=%remainer% && set /a D=%D% - 1 &; if %D%>=0 && goto :calccrtloop
if not %crt%%%D%>=175341304 && set crt=%crt%%%D% && set /a remainer=%remainer% - %proxy% ! set remainer=%olremain% && set N= && set decimal= && if %end%==Y && if %enddeci%==Y && set /a numdeci=%numdeci% - 1
#NOTE#(300crt^2+30crtD+D^2)D=max => 300crt^2+30crtD-((max/D)-D^2)=0 => crt^2+1/10crtD-((max/D)-D^2)/300=0 => (crt+9/10)^-81/100-((max/9-81)/300=0 => crt=-9/10+(C)^(1/2)
if not exist N && if %numdeci%==0 && set /a integer=%crt% && goto :calccrtend
if not exist N && if not exist decimal && if %numdeci%>=1 && set crt=000000%crt% &; call set /a integer=%^crt:~0,-%numdeci%%% && call set decimals=%^crt:~-%numdeci%,%numdeci%%% && goto :calccrtend
set olremain=%remainer%
if not exist N && if not exist decimal && if not %end%==Y && if not %remainer%==0 && set N=0000000000000000000000000000000000000000000000000000000 && set end=Y
if not exist N && set N=%decimal:~0,3% && set decimal=%decimal:~3% && set /a numdeci=%numdeci%+1 && set enddeci=Y
set /a remainer=%remainer%%%N:~0,3% && set N=%N:~3% &; set /a Nlen=%@retval%
set D=9
goto :calccrtloop
:calccrtend
if not %remainer%==0 && set D=9 && call :crtstage2
if not %remainer%==0 && set rounded=Y ! set lastrnd=
if exist decimals && if not exist fix && call :stripzerosafter "%decimals%" &; set decimals=%result% && set result=
if exist decimals && set result=%sign%%%integer%.%decimals% ! set result=%sign%%%integer%
goto :endlocal
::
:crtstage2
call :^ "noround" %integer%.%decimals%%%D% 3 &; set crtexp3=%result% && set result= &; call :"<=" "<=" %crtexp3% %N1%.%decimal1% &; if %result%==0 && set /a D=%D%-1 &; if %D%>=1 && set result= && goto :crtstage2 ! set result=1
if %result%==1 && if not %D%==0 && set result= && call :"==" "==" %crtexp3% %N1%.%decimal1% &; if %result%==1 && if not %lastrnd%==0 && set /a D=%D%-1 && set result= && goto :crtstage2 ! if %result%==1 && set remainer=0 && set decimals=%decimals%%%D% && set /a numdeci=%numdeci%+1 && set result= && goto :eof ! set result=1
if %result%==1 && set decimals=%decimals%%%D% && set /a numdeci=%numdeci%+1 && set result=
if %numdeci%<=6 && call :"==" "==" %crtexp3% %N1%.%decimal1% &; if %result%==1 && set remainer=0 && set result= && goto :eof
if %numdeci%>=%maxdeci% && set lastrnd=0 && goto :eof
set D=9 && set crtexp3= && set result=
goto :crtstage2
::
:hex
#-#+ HEX \tFunction HEX - Number before is converted to hexa-decimal
#-# Use\tCALCD.G4B number HEX\nRemarks\tPostfix function, existing result can be used instead of number\n\tInternally 19 digits, all decimals are cut-off, no rounding\n\tNegative numbers in Two's complement format (64-bits)\n\tIf variable 'hex' is set before, final result in hex\n\tIf 'deci' and/ or 'round' and/ or 'digi' and/ or 'fix' exists, 'hex'\n\tcomes last, but 'hex' is overruled by set-variable 'bin', 'bins'\n\tand 'thsep'. Set-variable 'hex' is case-sensitive!\n\tAny set-value is allowed, best use: set hex=Y\nExample CALCD.G4B 1 HEX\nExample CALCD.G4B -1 HEX\nExample CALCD.G4B 2 ^ 61 HEX\nExample CALCD.G4B -2 ^ 61 HEX\nExample CALCD.G4B 10.12345 HEX\nExample CALCD.G4B 10 / 6 HEX\nExample CALCD.G4B 10 / 6 ROUND 0 HEX\nExample CALCD.G4B --echo 10m / 7 HEX MS 10m / 6 HEX MP 10m / 5 HEX MP MR HEX\nExample CALCD.G4B 10m / 7 MS 10m / 6 MP 10m / 5 MP MR HEX\nExample CALCD.G4B STDEVP 500 1000 2000 3000 4000 5000 6000 7000 HEX\nExample CALCD.G4B 12345678912345678 SQRT DECI 0 HEX\nExample$[0x00]"$[]set hex=Y ;; --echoR CALCD.G4B 123456789.123456789 SQRT ^ 4\nExample$[0x00]"$[]set hex=Y ;; --echoR CALCD.G4B 123456789.123456789SQRT^4ROUND0
if "%~3"=="" && set fix= && set fixed=
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R%
if "%~2"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
shift
set n1=%~1 &; if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
call :operatorsinput %0 "%n1%" &; if exist message && goto :endlocal
if "%sign1%"=="-1" && set sign=- ! set sign=
set /A result=%sign%%%N1% && if %numdeci1%>=1 && set lastrnd=0
goto :endlocal
::
:ts
#-#+ TS \tFunction TS - alias of THSEP
:thsep
#-#+ THSEP \tFunction THSEP - Adds comma as thousands-separator to\n\tnumber before
#-# Use\tCALCD.G4B number THSEP (aliasses: TS THS THSP TSEP THSSEP)\nRemarks\tPostfix function, existing result can be used instead of number\n\tLast argument on command-line, earlier use of THSEP is ignored\n\tOutput: max 19 integers + 18 decimals, no rounding\n\tInputs with comma-thousands-separator allowed, output needs THSEP\n\tIf variable 'thsep' is set before, final result contains thousand\n\tseperator(s) and variable R will contain original number afterwards\n\tIf 'deci' and/ or 'round' and/ or 'digi' and/ or 'fix' and/ or 'hex'\n\tand/ or 'bin' and/ or 'bins' exists, 'thsep' comes last, overrules all\n\tSet-variable 'thsep' is case-sensitive!\n\tAny set-value is allowed, best use: set thsep=Y\nExample CALCD.G4B 10000000 THSEP\nExample CALCD.G4B 2555555.2555 THSEP\nExample CALCD.G4B -2050.456 / 0.001 THSEP\nExample CALCD.G4B -20,050,123.456 * -3,500 ROUND 4 THSEP\nExample CALCD.G4B -20,050,123.456 * -3,500 ROUND 4\nExample CALCD.G4B 2 ^ 32 THSEP\nExample CALCD.G4B 20! THSEP\nExample CALCD.G4B 2 ^ 62 THSEP\nExample CALCD.G4B 2^62MS-1MPMRTHSEP\nExample set\x20thsep=Y\x20;;\x20CALCD.G4B 2 ^ 62 MS - 1 MP MR\x20;;\x20set
setlocal && set *
if /i "%~1"=="nothsepar" &; call Fn.11 "%~2" "," || set thsepar=Y ! set thsepar=N
shift
if not exist n1 && set "n1=%~1" ! set n1=%n1% &; if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
call :operatorsinput THSEP "%n1%" &; if exist message && goto :endlocal
if %sign1%==-1 && set sign=-
if exist decimal1 && set R=%sign%%%N1%.%decimal1% ! set R=%sign%%%N1%
if %thsepar%==Y && set result=%R% && set R=%R% && goto :endlocal
set t=, && if not exist number && set number=%N1% && set decimals=%decimal1%
if %number%<=999 && set result=%number% ! if %number%<=9999 && set result=%number:~0,1%%%t%%%number:~1% ! if %number%<=99999 && set result=%number:~0,2%%%t%%%number:~2% ! if %number%<=999999 && set result=%number:~0,3%%%t%%%number:~3% ! if %number%<=9999999 && set result=%number:~0,1%%%t%%%number:~1,3%%%t%%%number:~4% ! if %number%<=99999999 && set result=%number:~0,2%%%t%%%number:~2,3%%%t%%%number:~5% ! if %number%<=999999999 && set result=%number:~0,3%%%t%%%number:~3,3%%%t%%%number:~6,3% ! if %number%<=9999999999 && set result=%number:~0,1%%%t%%%number:~1,3%%%t%%%number:~4,3%%%t%%%number:~7,3% ! if %number%<=99999999999 && set result=%number:~0,2%%%t%%%number:~2,3%%%t%%%number:~5,3%%%t%%%number:~8,3% ! if %number%<=999999999999 && set result=%number:~0,3%%%t%%%number:~3,3%%%t%%%number:~6,3%%%t%%%number:~9,3%
if %number%>=1000000000000 &; if %number%<=9999999999999 && set result=%number:~0,1%%%t%%%number:~1,3%%%t%%%number:~4,3%%%t%%%number:~7,3%%%t%%%number:~10,3% ! if %number%<=99999999999999 && set result=%number:~0,2%%%t%%%number:~2,3%%%t%%%number:~5,3%%%t%%%number:~8,3%%%t%%%number:~11,3% ! if %number%<=999999999999999 && set result=%number:~0,3%%%t%%%number:~3,3%%%t%%%number:~6,3%%%t%%%number:~9,3%%%t%%%number:~12,3% ! if %number%<=9999999999999999 && set result=%number:~0,1%%%t%%%number:~1,3%%%t%%%number:~4,3%%%t%%%number:~7,3%%%t%%%number:~10,3%%%t%%%number:~13,3% ! if %number%<=99999999999999999 && set result=%number:~0,2%%%t%%%number:~2,3%%%t%%%number:~5,3%%%t%%%number:~8,3%%%t%%%number:~11,3%%%t%%%number:~14,3% ! if %number%<=999999999999999999 && set result=%number:~0,3%%%t%%%number:~3,3%%%t%%%number:~6,3%%%t%%%number:~9,3%%%t%%%number:~12,3%%%t%%%number:~15,3% ! if %number%<=9999999999999999999 && set result=%number:~0,1%%%t%%%number:~1,3%%%t%%%number:~4,3%%%t%%%number:~7,3%%%t%%%number:~10,3%%%t%%%number:~13,3%%%t%%%%number:~16,3% ! set result=
if exist decimals && set result=%sign%%%result%.%decimals% ! set result=%sign%%%result%
goto :endlocal
::
:max
#-#+ MAX \tFunction MAX  - Highest of numbers behind
#-#  Use 1\tCALCD.G4B MAX number1 number2 [number3 ...]\nUse 2\tCALCD.G4B MAX [MD] FILE\nRemarks Prefix function, result can be used as input to infix or postfix\n\tfunctions. New prefix function restarts calculation\n\tFILE must be an md-device containing numbers only, max 255 sectors\n\tSeparators in FILE: spaces (20), 0A or 0D0A - MD optional\nExample CALCD.G4B MAX 1 2 3 4 5 6\nExample CALCD.G4B MAX 0.5 2.1 1.2 7.3 4 3.5 0.6\nExample CALCD.G4B MAX 1! 2! 3! 4! 5! 6!\nExample CALCD.G4B 5! MS MAX 1! 2! 3! 4! MR 6! 7! 8! THSEP\nExample CALCD.G4B MAX 1 2 3 4 5 6MSMAX 7 8 9 10*MR\nMake FILE: echo 0.5 1.5 2.5 3.5 4.5 5.5 0.05\x20>\x20(md)0x3000+255\nExample CALCD.G4B MAX (md)0x3000+255\nExample CALCD.G4B MAX (md)0x3000+255 ^ 2\nExample CALCD.G4B MAX (md)0x3000+255 MS 20! / MR
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if %~1==goback && set goback=Y
if "%~3"=="" &; if %goback%==Y && endlocal && set "message=Abort: argument(s) missing in MAX" && goto :eof ! endlocal && set "message=Abort: argument(s) missing in MAX" && goto :calcfpend
shift
if /i %~1==md &; if %~d2==(md) && set md=%~2 && shift && shift ! if %goback%==Y && endlocal && set "message=Abort MAX: (md)-device in '%~2' not found" && set result= && goto :eof ! endlocal && set "message=Abort MAX: (md)-device in '%~2' not found" && set result= && goto :calcfpend
if %~d1==(md) && set md=%~1 && shift
if exist md &; call Fn.11 "%md%" "+" |; if %goback%==Y && endlocal && set "message=Abort MAX: (md)-device in '%md%' not valid" && set result= && goto :eof ! endlocal && set "message=Abort MAX: (md)-device in '%md%' not valid" && set result= && goto :calcfpend
if exist md && if %md:~-3,3%>=256 &; if %goback%==Y && endlocal && set "message=Abort MAX: sectors of (md)-device in '%md%' above 255" && set result= && goto :eof ! endlocal && set "message=Abort MAX: sectors of (md)-device in '%md%' above 255" && set result= && goto :calcfpend
if not exist md && set N1=%~1 &; if /i %N1:~-2,2%==mr && set N1=%N1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %N1%==r && set N1=%R% ! if /i %N1%==-r && set N1=-%R%
if not exist md && set N2=%~2 &; if /i %N2:~-2,2%==mr && set N2=%N2:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %N2%==r && set N2=%R% ! if /i %N2%==-r && set N2=-%R%
if not exist md && call :">=" ">=" %N1% %N2% &; if exist result && if %result%==1 && set result=%N1% ! if %result%==0 && set result=%N2% ! if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && goto :eof ! endlocal && set "message=%message%" && set result=%result% && goto :calcfpend
if not exist md && if exist result && call :+ + "%result%" 0 &; if exist message &; if %goback%==Y && endlocal && set result= && set "message=%message%" && goto :eof ! endlocal && set "message=%message%" && set result= && goto :calcfpend
if not exist md &; if not "%~3"=="" && shift && shift && goto :maxloop ! if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && goto :eof ! endlocal && set "message=%message%" && set result=%result% && goto :calcfpend
cat %md% | call :maxloop &; if exist result && call :+ + "%result%" 0 &; if exist message &; if %goback%==Y && endlocal && set result= && set "message=%message%" && goto :eof ! endlocal && set "message=%message%" && set result= && goto :calcfpend
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :calcfploop
if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfprestart
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if %goback%==Y && endlocal && set result=%result% && set "message=%message%" && goto :eof ! endlocal && set result=%result% && set "message=%message%" && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfpend
:maxloop
if exist md && if "%~1"=="" && goto :eof
if exist md && if exist result && set max=%result% && call :">=" ">=" %~1 "%result%" &; if exist result && if %result%==1 && set result=%~1 ! if %result%==0 && set result=%max% ! goto :eof
if exist md && if not exist result && call :">=" ">=" %~1 %~2 &; shift &; if exist result && if %result%==1 && set result=%~1 ! if %result%==0 && set result=%~2 ! goto :eof
if exist md && shift && goto :maxloop
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfprestart
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="" && set N1=%~1 &; if /i %N1:~-2,2%==mr && set N1=%N1:~0,-2%%%MR% && set lastrnd=%memrnd%
if not "%~1"=="" && set max=%result% && call :">=" ">=" %N1% "%result%" &; if exist result && if %result%==1 && set result=%N1% && shift ! if %result%==0 && set result=%max% && shift ! endlocal && set "message=%message%" && set result= && goto :calcfpend
if not "%~1"=="" && goto :maxloop
:maxend
if exist result && call :+ + "%result%" 0
if %goback%==Y && endlocal && set "message=%message%" && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof
endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd%
goto :calcfpend
::
:min
#-#+ MIN \tFunction MIN  - Lowest of numbers behind
#-#  Use 1\tCALCD.G4B MIN number1 number2 [number3 ...]\nUse 2\tCALCD.G4B MIN [MD] FILE\nRemarks Prefix function, result can be used as input to infix or postfix\n\tfunctions. New prefix function restarts calculation\n\tFILE must be an md-device containing numbers only, max 255 sectors\n\tSeparators in FILE: spaces (20), 0A or 0D0A - MD optional\nExample CALCD.G4B MIN 1 2 3 4 5 6\nExample CALCD.G4B MIN 0.5 2.1 1.2 7.3 4 3.5 0.6\nExample CALCD.G4B MIN 1! 2! 3! 4! 5! 6!\nExample CALCD.G4B 5! MS MIN 1! 2! 3! 4! MR 6! 7! 8! THSEP\nExample CALCD.G4B MIN 1 2 3 4 5 6MSMIN 7 8 9 10*MR\nMake FILE: echo 0.5 1.5 2.5 3.5 4.5 5.5 0.05\x20>\x20(md)0x3000+255\nExample CALCD.G4B MIN (md)0x3000+255\nExample CALCD.G4B MIN (md)0x3000+255 ^ 2\nExample CALCD.G4B MIN (md)0x3000+255 MS 20! / MR
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if %~1==goback && set goback=Y
if "%~3"=="" &; if %goback%==Y && endlocal && set "message=Abort: argument(s) missing in MIN" && goto :eof ! endlocal && set "message=Abort: argument(s) missing in MIN" && goto :calcfpend
shift
if /i %~1==md &; if %~d2==(md) && set md=%~2 && shift && shift ! if %goback%==Y && endlocal && set "message=Abort MIN: (md)-device in '%~2' not found" && set result= && goto :eof ! endlocal && set "message=Abort MIN: (md)-device in '%~2' not found" && set result= && goto :calcfpend
if %~d1==(md) && set md=%~1 && shift
if exist md &; call Fn.11 "%md%" "+" |; if %goback%==Y && endlocal && set "message=Abort MIN: (md)-device in '%md%' not valid" && set result= && goto :eof ! endlocal && set "message=Abort MIN: (md)-device in '%md%' not valid" && set result= && goto :calcfpend
if exist md && if %md:~-3,3%>=256 &; if %goback%==Y && endlocal && set "message=Abort MIN: sectors of (md)-device in '%md%' above 255" && set result= && goto :eof ! endlocal && set "message=Abort MIN: sectors of (md)-device in '%md%' above 255" && set result= && goto :calcfpend
if not exist md && set N1=%~1 &; if /i %N1:~-2,2%==mr && set N1=%N1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %N1%==r && set N1=%R% ! if /i %N1%==-r && set N1=-%R%
if not exist md && set N2=%~2 &; if /i %N2:~-2,2%==mr && set N2=%N2:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %N2%==r && set N2=%R% ! if /i %N2%==-r && set N2=-%R%
if not exist md && call :"<=" "<=" %N1% %N2% &; if exist result && if %result%==1 && set result=%N1% ! if %result%==0 && set result=%N2% ! if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && goto :eof ! endlocal && set "message=%message%" && set result=%result% && goto :calcfpend
if not exist md && if exist result && call :+ + "%result%" 0 &; if exist message &; if %goback%==Y && endlocal && set result= && set "message=%message%" && goto :eof ! endlocal && set "message=%message%" && set result= && goto :calcfpend
if not exist md &; if not "%~3"=="" && shift && shift && goto :minloop ! if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && goto :eof ! endlocal && set "message=%message%" && set result=%result% && goto :calcfpend
cat %md% | call :minloop  &; if exist result && call :+ + "%result%" 0 &; if exist message &; if %goback%==Y && endlocal && set result= && set "message=%message%" && goto :eof ! endlocal && set "message=%message%" && set result= && goto :calcfpend
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :calcfploop
if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfprestart
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if %goback%==Y && endlocal && set result=%result% && set "message=%message%" && goto :eof ! endlocal && set result=%result% && set "message=%message%" && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfpend
:minloop
if exist md && if "%~1"=="" && goto :eof
if exist md && if exist result && set min=%result% && call :"<=" "<=" %~1 "%result%" &; if exist result && if %result%==1 && set result=%~1 ! if %result%==0 && set result=%min% ! goto :eof
if exist md && if not exist result && call :"<=" "<=" %~1 %~2 &; shift &; if exist result && if %result%==1 && set result=%~1 ! if %result%==0 && set result=%~2 ! goto :eof
if exist md && shift && goto :minloop
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfprestart
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; if %goback%==Y && endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof ! endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="" && set N1=%~1 &; if /i %N1:~-2,2%==mr && set N1=%N1:~0,-2%%%MR% && set lastrnd=%memrnd%
if not "%~1"=="" && set min=%result% && call :"<=" "<=" %N1% "%result%" &; if exist result && if %result%==1 && set result=%N1% && shift ! if %result%==0 && set result=%min% && shift ! endlocal && set "message=%message%" && set result= && goto :calcfpend
if not "%~1"=="" && goto :minloop
:minend
if exist result && call :+ + "%result%" 0
if %goback%==Y && endlocal && set "message=%message%" && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :eof
endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd%
goto :calcfpend
::
:countif
#-#+ COUNTIF \tFunction COUNTIF  - Count of numbers behind satisfying 'if'-condition
#-#  Use 1\tCALCD.G4B COUNTIF "==n"|"=>n"|"<=n"|">n"|"<n" number1 number2 [numbern]\nUse 2\tCALCD.G4B COUNTIF "==n"|"=>n"|"<=n"|">n"|"<n" [MD] FILE\nRemarks Prefix function, result can be used as input to infix or postfix\n\tfunctions. New prefix function restarts calculation\n\tFILE must be an md-device containing numbers only, max 255 sectors\n\tSeparators in FILE: spaces (20), 0A or 0D0A - MD optional\n\tSpaces around 'if'-condition mandatory!\n\tn \xF110exp-18 - 2exp63-1, 0!-20!, MR, R (integers hex too, decimals: dot)\nExample CALCD.G4B COUNTIF "==3" 1 2 3 1 2 3\nExample CALCD.G4B COUNTIF ">=3" 1 2 3 4 5 6\nExample CALCD.G4B COUNTIF "<=1.5" 0.5 1.5 2.5 3.5 4.5 5.5 0.05\nExample CALCD.G4B COUNTIF ">=1k" 1,000 1010 0x3F2 1030 1,040 1k\nExample CALCD.G4B COUNTIF "<3!" 0! 1! 2! 3! 4! 5! 4! 3! 2! 1! 0!\nExample CALCD.G4B  5!MS COUNTIF "<=MR" 1! 2! 3! 4! MR 6! 7!*8!THSEP\nExample CALCD.G4B COUNTIF ">=3" 1 2 3 4 5 MS \x3B\x3B if \x25MR\x25>=4\x20&&\x20CALCD.G4B MR ^ MR\nMake FILE: echo 0.5 1.5 2.5 3.5 4.5 5.5 0.05\x20>\x20(md)0x3000+255\nExample CALCD.G4B COUNTIF "==3" (md)0x3000+255\nExample CALCD.G4B COUNTIF ">=3" (md)0x3000+255 ^ 2\nExample CALCD.G4B COUNTIF "<=5.49" (md)0x3000+255 MS \x3B\x3B if \x25MR\x25<=6 echo GOOD
if /i "%~1"=="countif" && shift ! set "message=Abort COUNTIF: wrong call" && set result= && goto :calcfpend
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
set "ARG=%~1" &; if "%ARG:~0,2%"=="==" && set "if===" && set C=%ARG:~2% ! if "%ARG:~0,2%"==">=" && set "if=>=" && set C=%ARG:~2% ! if "%ARG:~0,1%"==">" && set "if=>" && set C=%ARG:~1% ! if "%ARG:~0,2%"=="<=" && set "if=<=" && set C=%ARG:~2% ! if "%ARG:~0,1%"=="<" && set "if=<" && set C=%ARG:~1%
shift
if /i %~1==md &; if %~d2==(md) && set md=%~2 && shift && shift ! endlocal && set "message=Abort COUNTIF: (md)-device in '%~2' not found" && set result= && goto :calcfpend
if %~d1==(md) && set md=%~1 && shift
if exist md &; call Fn.11 "%md%" "+" |; endlocal && set "message=Abort COUNTIF: (md)-device in '%md%' not valid" && set result= && goto :calcfpend
if exist md && if %md:~-3,3%>=256 && endlocal && set "message=Abort COUNTIF: sectors of (md)-device in '%md%' above 255" && set result= && goto :calcfpend
if not exist md && if "%~2"=="" && endlocal && set "message=Abort: argument(s) missing in COUNTIF" && goto :calcfpend
set count=0 && if not exist md && goto :countifloop
cat %md% | call :countifloop  &; if not exist count && endlocal && set "message=%message%" && set result= && goto :calcfpend
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :calcfploop
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; endlocal && set result=%result% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd% && goto :calcfploop
if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfprestart
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; endlocal && set result=%result% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
goto :endcountif
:countifloop
if "%~1"=="" &; if not exist md && goto :endcountif ! goto :eof
if not exist md &; if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; endlocal && set result=%count% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not exist md &; if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; endlocal && set result=%count% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
if not exist md &; if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; endlocal && set result=%count% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfprestart
if not exist md &; if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; endlocal && set result=%count% && set rounded=%rounded% && set lastrnd=%lastrnd% && goto :calcfploop
set n=%~1 &; if /i %n:~-2,2%==mr && set n=%n:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n%==r && set n=%R% ! if /i %n%==-r && set n=-%R%
if /i "%n:~-1,1%"=="!" && set n=%n:~0,-1% &; if %n:~0,1%==- && set n=%n:~1% && set sign=- ! set sign= &; call :fact goback %n% &; if exist result && set n=%sign%%%result% && set result= ! if exist md && set count= && goto :eof ! endlocal && set result= && set "message=%message%" && goto :calcfpend
if "%if%"=="==" && call :"==" "==" %n% %C% &; if %result%==1 && set /a count=%count%+1 && set result= ! if %result%==0 && result= ! if exist md && set count= && goto :eof ! endlocal && set result= && set "message=%message%" && goto :calcfpend
if "%if%"==">=" && call :">=" ">=" %n% %C% &; if %result%==1 && set /a count=%count%+1 && result= ! if %result%==0 && result= ! if exist md && set count= && goto :eof ! endlocal && set result= && set "message=%message%" && goto :calcfpend
if "%if%"=="<" && call :">=" ">=" %n% %C% &; if %result%==0 && set /a count=%count%+1 && result= ! if %result%==1 && result= ! if exist md && set count= && goto :eof ! endlocal && set result= && set "message=%message%" && goto :calcfpend
if "%if%"=="<=" && call :"<=" "<=" %n% %C% &; if %result%==1 && set /a count=%count%+1 && result= ! if %result%==0 && result= ! if exist md && set count= && goto :eof ! endlocal && set result= && set "message=%message%" && goto :calcfpend
if "%if%"==">" && call :"<=" "<=" %n% %C% &; if %result%==0 && set /a count=%count%+1 && result= ! if %result%==1 && result= ! if exist md && set count= && goto :eof ! endlocal && set result= && set "message=%message%" && goto :calcfpend
shift && goto :countifloop
:endcountif
endlocal && set result=%count% && set rounded=%rounded% && set "message=%message%" && set lastrnd=%lastrnd%
goto :calcfpend
::
:roundup
#-#+ ROUNDUP \tFunction ROUNDUP - Number before is rounded up to given number of\n\tdecimals or integers
#-# Use\tCALCD.G4B [switch] number1 ROUNDUP NUMBER\nRemarks Infix function, existing result can be used instead of number1\n\tRounding up in earlier result is undone first (remains with ROUNDUP 18)\n\tIf NUMBER >=0 roundup decimals, ignored if not enough decimals\n\tif NUMBER <=-1 roundup integers, ignored if not enough integers\n\tIf variable 'roundup' is set before CALCD.G4B, result is rounded up\n\tUsing ROUNDUP last on command-line overides set-variable 'roundup'\n\tIf 'round' exists too, 'roundup' is first\n\tIf 'digi' exists too and if 'rounded=Y', 'roundup' will be ignored\n\tIf 'fix' exists too, 'roundup' will be ignored\n\tSet-variable 'roundup' is case-sensitive!\nExample CALCD.G4B 0.12345 ROUNDUP 4\nExample CALCD.G4B 10 / 7 ROUNDUP 4\nExample CALCD.G4B 10 / 7 ROUNDUP 4 * 7\nExample CALCD.G4B STDEVP 1 2 3 4 5 6 7 ROUNDUP 8\nExample CALCD.G4B 12345678912345678 SQRT ROUNDUP 0\nExample$[0x00]"$[0x07]set roundup=0 ;; CALCD.G4B 12345678912345678 SQRT\nExample$[0x00]"$[0x07]set roundup=0 ;; CALCD.G4B 12345678912345678SQRTROUNDUP-2
if "%~4"=="" && set roundup=
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set echor=%echor% && set echoMR=%echoMR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~3"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal
shift
set n1=%~1
if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
set n2=%~2
set fix=Y && call :operatorsinput %0 "%n1%" "%n2%" &; if exist message && goto :endlocal
if %sign1%==-1 && set sign=-
if %lastrnd%==1 && if %numdeci1%>=1 && set /a decidiff=%numdeci1% - %N2% &; if %decidiff%>=1 &; set /a decimal1=%decimal1% - 1 &; set decimal1=000000000000000000%decimal1% &; call set decimal1=%^decimal1:~-%numdeci1%,%numdeci1%%%
if %sign2%==1 && if not exist decimal1 && set result=%n1% && goto :endlocal
if %sign2%==1 && if %N2%>=%numdeci1% && set result=%sign%%%N1%.%decimal1:~0,18% && goto :endlocal
if %sign2%==1 &; call if %^decimal1:~%N2%,1%>=0 && set round=1 && set lastrnd=1
if %sign2%==1 && call set decimal1=%^decimal1:~0,%N2%%% && set rounded=Y
if %sign2%==1 && if %N2%>=1 && set round=000000000000000000%round% &; call set round=%^round:~-%N2%,%N2%%%
if %sign2%==1 && if %N2%>=1 &; if not %round%==0 && call :+ + %sign1:~0,-1%%%N1%.%decimal1% %sign1:~0,-1%%0.%round% ! set result=%sign1:~0,-1%%%N1%.%decimal1%
if %sign2%==1 && if %N2%==0 && set /a result=%sign1% * %N1% + %sign1:~0,-1%%%round%
if %sign2%==1 && goto :endlocal
if %N1%>=1 && set N1=%N1% &; set /a N1len=%@retval% &; if %N2%>=%N1len% && set /a N2=%N1len%-1
if %N1%==0 && set result=%n1% && goto :endlocal
call if %^N1:~-%N2%,1%>=0 && set round=1 ! set round=0
call set N1=%^N1:~0,-%N2%%% && set rounded=Y
set N=000000000000000000 &; call set N=%^N:~0,%N2%%% && set rounded=Y
set /a result=%sign1% * %N1% + %sign1:~0,-1%%%round% &; set /a result=%result%%%N%
goto :endlocal
::
:bins
#-#+ BINS \tFunction BINS - Use 'help BIN'
:bin
#-#+ BIN \tFunction BIN - Number before is converted to binary (0b before bits)\n\tBINS splits result too: 0b nibbles
#-# Use\tCALCD.G4B number BIN\nRemarks\tPostfix function, existing result can be used instead of number\n\t(ungrouped!). Internally 19 digits, all decimals are cut-off\n\tNegative numbers in Two's Complement format (64-bits)\n\tIf variable 'bin'/ 'bins' is set before, final result in bin[s]\n\tIf 'deci' and/ or 'round' and/ or 'digi' and/ or 'fix' or 'hex' exists,\n\t'bin'/ 'bins' comes last, but overruled by set-variable 'thsep'\n\tSet-variable 'bin' is case-sensitive!\n\tAny set-value is allowed, best use: 'set bin=Y' or 'set bins=Y'\nExample CALCD.G4B 1 BIN\nExample CALCD.G4B -1 BIN\nExample CALCD.G4B 2 ^ 61 BINS\nExample CALCD.G4B -2 ^ 61 BINS\nExample CALCD.G4B 1g BINS\nExample CALCD.G4B 10 / 6 BIN\nExample CALCD.G4B --echo 10m / 7 BIN MS 10m / 6 BIN MP 10m / 5 BIN MP MR BINS\nExample CALCD.G4B 10m / 7 MS 10m / 6 MP 10m / 5 MP MR * 7k BIN\nExample CALCD.G4B STDEVP 500 1000 2000 3000 4000 5000 6000 7000 BIN\nExample CALCD.G4B 12345678912345678SQRTDECI-1BIN\nExample$[0x00]"$[]set bin=Y ;; CALCD.G4B --echoR 123456789.123456789 SQRT ^ 4\nExample$[0x00]"$[]set bins=Y ;; CALCD.G4B --echoR 123456789.123456789 SQRT ^ 4 ROUND 0
if "%~3"=="" && set fix= && set fixed=
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set echor=%echor% && set echoMR=%echoMR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix% && set split=%split%
if "%~2"=="" && set "message=Abort: argument(s) missing in %0" && goto :endlocal ! shift
set n1=%~1 &; if /i %n1:~-2,2%==mr && set n1=%n1:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %n1%==r && set n1=%R% ! if /i %n1%==-r && set n1=-%R%
if /i "%n1:~-1,1%"=="!" && set n1=%n1:~0,-1% &; if %n1:~0,1%==- && set n1=%n1:~1% && set sign=- ! set sign= &; call :fact goback %n1% &; if exist result && set n1=%sign%%%result% && set result= ! set rounded= && goto :endlocal
if /i "%~0"=="bins" && if "%~2"=="" && set split=Y
call :operatorsinput %0 "%n1%" &; if exist message && goto :endlocal
if "%sign1%"=="-1" && set sign=- ! set sign=
set /A N1=%sign%%%N1%
#NoNeed:NegativeHexAlways16Bytes# &; set /a N1len=%@retval% &; echo %0 A N1=%N1% N1len=%N1len% &; if %sign%==- &; calc %N1len% % 2 && set N1=0x0N1:~2% && set /a N1len=%N1len%+1
:binloop
set /a bit0=%N1%>>0&1 && set /a bit1=%N1%>>1&1 && set /a bit2=%N1%>>2&1 && set /a bit3=%N1%>>3&1 && set /a bit4=%N1%>>4&1 && set /a bit5=%N1%>>5&1 && set /a bit6=%N1%>>6&1 && set /a bit7=%N1%>>7&1
set BIN=%bit7%%%bit6%%%bit5%%%bit4%%%bit3%%%bit2%%%bit1%%%bit0%%%BIN%
if not %sign%==- && set /A N1=%N1%>>8 ! set /A N1=%N1:~0,-2%
if %N1%>=1 && goto :binloop
if %BIN%==0 && set BIN=0
if not %BIN%==0 && if %BIN:~0,1%==0 && call :stripzerosbefore "%BIN%" &; set BIN=%result%
if %split%==Y && set BIN=%BIN% &; set /a BINlen=%@retval% &; set BIN=000%BIN% &; if %BINlen%<=4 && set BIN=%BIN:~-4,4% ! if %BINlen%<=8 && set BIN=%BIN:~-8,4% %BIN:~-4,4% ! if %BINlen%<=12 && set BIN=%BIN:~-12,4% %BIN:~-8,4% %BIN:~-4,4% ! if %BINlen%<=16 && set BIN= %BIN:~-16,4% %BIN:~-12,4% %BIN:~-8,4% %BIN:~-4,4% ! if %BINlen%<=20 && set BIN=%BIN:~-20,4% %BIN:~-16,4% %BIN:~-12,4% %BIN:~-8,4% %BIN:~-4,4% ! if %BINlen%<=24 && set BIN= %BIN:~-24,4% %BIN:~-20,4% %BIN:~-16,4% %BIN:~-12,4% %BIN:~-8,4% %BIN:~-4,4% ! if %BINlen%<=28 && set BIN=%BIN:~-28,4% %BIN:~-24,4% %BIN:~-20,4% %BIN:~-16,4% %BIN:~-12,4% %BIN:~-8,4% %BIN:~-4,4% ! if %BINlen%<=32 && set BIN=%BIN:~-32,4% %BIN:~-28,4% %BIN:~-24,4% %BIN:~-20,4% %BIN:~-16,4% %BIN:~-12,4% %BIN:~-8,4% %BIN:~-4,4% ! if %BINlen%<=36 && set BIN=%BIN:~-36,4% %BIN:~-32,4% %BIN:~-28,4% %BIN:~-24,4% %BIN:~-20,4% %BIN:~-16,4% %BIN:~-12,4% %BIN:~-8,4% %BIN:~-4,4% ! if %BINlen%<=40 && set BIN=%BIN:~-40,4% %BIN:~-36,4% %BIN:~-32,4% %BIN:~-28,4% %BIN:~-24,4% %BIN:~-20,4% %BIN:~-16,4% %BIN:~-12,4% %BIN:~-8,4% %BIN:~-4,4% ! if %BINlen%<=44 && set BIN=%BIN:~-44,4% %BIN:~-40,4% %BIN:~-36,4% %BIN:~-32,4% %BIN:~-28,4% %BIN:~-24,4% %BIN:~-20,4% %BIN:~-16,4% %BIN:~-12,4% %BIN:~-8,4% %BIN:~-4,4%
if %split%==Y && if not %BINlen%<=44 &; if %BINlen%<=48 && set BIN=%BIN:~-48,4% %BIN:~-44,4% %BIN:~-40,4% %BIN:~-36,4% %BIN:~-32,4% %BIN:~-28,4% %BIN:~-24,4% %BIN:~-20,4% %BIN:~-16,4% %BIN:~-12,4% %BIN:~-8,4% %BIN:~-4,4% ! if %BINlen%<=52 && set BIN=%BIN:~-52,4% %BIN:~-48,4% %BIN:~-44,4% %BIN:~-40,4% %BIN:~-36,4% %BIN:~-32,4% %BIN:~-28,4% %BIN:~-24,4% %BIN:~-20,4% %BIN:~-16,4% %BIN:~-12,4% %BIN:~-8,4% %BIN:~-4,4% ! if %BINlen%<=56 && set BIN=%BIN:~-56,4% %BIN:~-52,4% %BIN:~-48,4% %BIN:~-44,4% %BIN:~-40,4% %BIN:~-36,4% %BIN:~-32,4% %BIN:~-28,4% %BIN:~-24,4% %BIN:~-20,4% %BIN:~-16,4% %BIN:~-12,4% %BIN:~-8,4% %BIN:~-4,4% ! if %BINlen%<=60 && set BIN=%BIN:~-60,4% %BIN:~-56,4% %BIN:~-52,4% %BIN:~-48,4% %BIN:~-44,4% %BIN:~-40,4% %BIN:~-36,4% %BIN:~-32,4% %BIN:~-28,4% %BIN:~-24,4% %BIN:~-20,4% %BIN:~-16,4% %BIN:~-12,4% %BIN:~-8,4% %BIN:~-4,4% ! if %BINlen%<=64 && set BIN=%BIN:~-64,4% %BIN:~-60,4% %BIN:~-56,4% %BIN:~-52,4% %BIN:~-48,4% %BIN:~-44,4% %BIN:~-40,4% %BIN:~-36,4% %BIN:~-32,4% %BIN:~-28,4% %BIN:~-24,4% %BIN:~-20,4% %BIN:~-16,4% %BIN:~-12,4% %BIN:~-8,4% %BIN:~-4,4%
if %split%==Y && set result=0b %BIN% ! set result=0b%BIN%
goto :endlocal
::
:bin2decimal
setlocal
set /l n=%~1 &; if "%n:~0,2%"=="0b" && set n=%n:~2% ! if "%n:~0,3%"=="-0b" && set n=%n:~3% && set sign=-
if %n:~0,1%==0 && call :stripzerosbefore "%n%" &; set n=%result%
set /A hex=0
set n=%n% &; if %@retval%==66 && if %sign%==- && set sign=
:bin2deciloop
set n=%n% &; set /a nlen=%@retval%
if %nlen%>=1 &; if %n:~-1,1%==1 && set /A hex=%hex%+1
if %nlen%>=2 &; if %n:~-2,1%==1 && set /A hex=%hex%+2
if %nlen%>=3 &; if %n:~-3,1%==1 && set /A hex=%hex%+4
if %nlen%>=4 &; if %n:~-4,1%==1 && set /A hex=%hex%+8
set HEX=%hex%%%HEX:~2%
if %nlen%>=5 && set n=%n:~0,-4% && set /A hex=0 && goto :bin2deciloop
set /a result=%HEX% &; if %sign%==- &; if %result%<=-1 && set result=%result:~1% ! set result=-%result%
endlocal && set result=%result%
goto :eof
::
:join
#-#+ JOIN \tFunction JOIN  - Join arguments behind (remove spaces)
#-#  Use 1\tCALCD.G4B JOIN argument1 argument2 [argumentN] \\\\\nUse 2\tCALCD.G4B JOIN [MD] FILE\nRemarks Prefix function, result can be used as input to infix or postfix\n\tfunctions. New prefix function restarts calculation\n\tFILE must be an md-device containing numbers only, max 255 sectors\n\tSeparators in FILE: spaces (20), 0A or 0D0A - MD optional\nExample CALCD.G4B JOIN 0b 1 0000 0000 \\\\\nExample CALCD.G4B JOIN 0x FF 00 FF AA 00\\\\THSEP\nMake FILE: echo 0b 1000 0100 0010 0001\x20>\x20(md)0x3000+255\nExample CALCD.G4B JOIN (md)0x3000+1 HEX
setlocal && set *
if "%~1"=="goback" && set goback=Y
if "%~2"=="" &; if %goback%==Y && endlocal && set "message=Abort: 'argument' is missing in JOIN" && goto :eof ! endlocal && set "message=Abort: 'argument' is missing in JOIN" && goto :calcfpend
shift
if /i %~1==md &; if %~d2==(md) && set md=%~2 && shift && shift ! if %goback%==Y && endlocal && set "message=Abort JOIN: (md)-device in '%~2' not found" && goto :eof ! endlocal && set "message=Abort JOIN: (md)-device in '%~2' not found" && goto :calcfpend
if %~d1==(md) && set md=%~1 && shift
if exist md &; call Fn.11 "%md%" "+" |; if %goback%==Y && endlocal && set "message=Abort JOIN: (md)-device in '%md%' not valid" && goto :eof ! endlocal && set "message=Abort JOIN: (md)-device in '%md%' not valid" && goto :calcfpend
if exist md && if %md:~-3,3%>=256 &; if %goback%==Y && endlocal && set "message=Abort JOIN: sectors of (md)-device in '%md%' above 255" && goto :eof ! endlocal && set "message=Abort JOIN: sectors of (md)-device in '%md%' above 255" && goto :calcfpend
if not exist md && goto :joinloop
cat %md% | call :joinloop  &; if not exist result && endlocal && set "message=%md% has no valid chars, no JOIN possible" && goto :eof
if not /i "%~1"=="sqrt" if not /i "%~1"=="cbrt" if not /i "%~1"=="inv" if not /i "%~1"=="ms" if not /i "%~1"=="mp" if not /i "%~1"=="mn" if not /i "%~1"=="srm" if not "%~1"=="\\" if not /i "%~1"=="hex" if not /i "%~1"=="sq" if not /i "%~1"=="cb" if not /i "%~1"=="thsep" if not /i "%~1"=="bin" if not /i "%~1"=="bins" if not /i "%~1"=="ln" if not /i "%~1"=="log" if not /i "%~1"=="ex" if not /i "%~1"=="10x" if not /i "%~1"=="abs" |; if %goback%==Y && endlocal && set result=%result% && goto :eof ! endlocal && set result=%result% && goto :calcfploop
if not "%~1"=="+" if not "%~1"=="-" if not "%~1"=="*" if not "%~1"=="/" if not "%~1"=="^" if not /i "%~1"=="round" if not /i "%~1"=="deci" if not /i "%~1"=="digi" if not /i "%~1"=="fix" if not /i "%~1"=="rounddown" if not /i "%~1"=="roundup" |; if %goback%==Y && endlocal && set result=%result% && goto :eof ! endlocal && set result=%result% && goto :calcfploop
if not /i "%~1"=="sum" if not /i "%~1"=="count" if not /i "%~1"=="mean" if not /i "%~1"=="product" if not /i "%~1"=="fact" if not /i "%~1"=="varp" if not /i "%~1"=="vars" if not /i "%~1"=="stdevp" if not /i "%~1"=="stdevs" if not /i "%~1"=="Pnr" if not /i "%~1"=="Cnr" if not "%~1"=="==" if not "%~1"==">=" if not "%~1"=="<=" if not /i "%~1"=="max" if not /i "%~1"=="min" if not /i "%~1"=="countif" if not /i "%~1"=="join" |; if %goback%==Y && endlocal && set result=%result% && goto :eof ! endlocal && set result=%result% && goto :calcfprestart
if not /i "%~1"=="ts" if not /i "%~1"=="tsp" if not /i "%~1"=="tsep" if not /i "%~1"=="ths" if not /i "%~1"=="thsp" if not /i "%~1"=="thsep" if not /i "%~1"=="thssep" |; if %goback%==Y && endlocal && set result=%result% && goto :eof ! endlocal && set result=%result% && goto :calcfploop
if "%~1"=="\\" && shift
if %goback%==Y && endlocal && set "message=%message%" && set result=%result% && goto :eof ! endlocal && set "message=%message%" && set result=%result% && goto :calcfploop
:joinloop
if not "%~1"=="" && set "result=%result%%%~1" && shift && if not "%~2"=="\\" && goto :joinloop
if exist md && goto :eof
if "%~1"=="\\" && shift &; if %goback%==Y && endlocal && set result=%result% && goto :eof ! endlocal && set result=%result% && goto :calcfploop
endlocal && set result=%result% && set "message=%message%"
goto :calcfpend
::
:log
#-#+ LOG \tFunction LOG - Common logarithm of number before (base: 10)
#-# Use\tCALCD.G4B number LOG\nRemarks\tPostfix function, existing result can be used instead of number\n\tHighest number: 9.223exp18 or 0x7FFFFFFFFFFFFFFF\n\tAccuracy: about 16 digits, small numbers less\nExample CALCD.G4B 10 LOG\nExample CALCD.G4B 10 LOG DIGI 16\nExample CALCD.G4B 0.2555 LOG\nExample CALCD.G4B 0.1 LOG\nExample CALCD.G4B 0.01 LOG\nExample CALCD.G4B 0.003 LOG\nExample CALCD.G4B 0.0003 LOG\nExample CALCD.G4B 2050.456 LOG\nExample CALCD.G4B 2,050.456 LOG\nExample CALCD.G4B 0.000000000123456789 LOG\nExample CALCD.G4B 256 LOG\nExample CALCD.G4B 256LOGMS 10LOG SRM/MR\nExample CALCD.G4B 3! LOG
:ln
#-#+ LN \tFunction LN - Natural logarithm of number before (base: e)
#-# Use\tCALCD.G4B number LN\nRemarks\tPostfix function, existing result can be used instead of number\n\tHighest number: 9.223exp18 or 0x7FFFFFFFFFFFFFFF\n\tAccuracy: about 16 digits, small numbers less\nExample CALCD.G4B e LN\nExample CALCD.G4B e LN DIGI 16\nExample CALCD.G4B 10 LN\nExample CALCD.G4B 0.2555 LN\nExample CALCD.G4B 0.1 LN\nExample CALCD.G4B 0.1 LN\nExample CALCD.G4B 0.02 LN\nExample CALCD.G4B 0.02 LN\nExample CALCD.G4B 2050.456 LN\nExample CALCD.G4B 2,050.456 LN\nExample CALCD.G4B 0.000000000123456789 LN\nExample CALCD.G4B 256 LN\nExample CALCD.G4B 256LNMS 10LN SRM/MR\nExample CALCD.G4B 3! LN
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
set postfix=%~0 &; if /i %postfix%==:log && set log=Y
if "%~1"=="goback" && set goback=Y && shift
if "%~2"=="" && set "message=Abort: number is missing before '%postfix%'" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal
shift
set N=%~1 && shift && set add=0 &; if /i %N:~-2,2%==mr && set N=%N:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %N%==r && set N=%R% ! if /i %N%==-r && set N=-%R%
if %N:~0,1%==- && set "message=Bad input: check '%N%'" && goto :endlocal
if /i "%N:~-1,1%"=="!" && set N=%N:~0,-1% &; call :fact goback %N% &; if exist result && set N=%result% && set result= ! set rounded= && goto :endlocal
:edividerloop
set result= && call :">=" ">=" "%N%" "1" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if not exist result && goto :endlocal
if %result%==1 && set /a add=%add%+1 && call :* * "%N%" "0.5" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set N=%result% && goto :edividerloop ! if exist message && goto :endlocal
:emultiplicatorloop
set result= && call :">=" ">=" "%N%" "0.5" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if not exist result && goto :endlocal
if %result%==0 && set /a add=%add%-1 && call :* * "%N%" "2" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set N=%result% && goto :emultiplicatorloop ! if exist message && goto :endlocal
set result= && call :- - "%N%" 1 &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set x=%result% ! goto :endlocal
set sum=%x% && set exp=2
:lntaylorseriesloop
set result= && call :^ ^ "%x%" "%exp%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if not exist result && goto :endlocal
if not %result:~2%==0 &; call :/ / "%result%" "%exp%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if not exist result && goto :endlocal
if not %result:~2%==0 &; calc %exp% % 2 &; call :+ + "%sum%" "%result%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set sum=%result% ! goto :endlocal
if not %result:~2%==0 &; calc %exp% % 2 |; call :- - "%sum%" "%result%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set sum=%result% ! goto :endlocal
if not %result:~2%==0 &; if not %exp%>=55 && set /a exp=%exp%+1 && set result= && goto :lntaylorseriesloop
if %add%>=1 && set result= && call :* * "0.693147180559945309" "%add%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set add=%result% ! goto :endlocal
if %add%<=-1 && set result= && call :* * "0.693147180559945309" "%add%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set add=%result% ! goto :endlocal
if exist add && set result= && call :+ + "%sum%" "%add%"
if %log%==Y && if exist result && call :/ / "%result%" 2.302585092994045684
if %goback%==Y && endlocal && set result=%result% && set "message=%message%" && goto :eof
goto :endlocal
::
:10x
#-#+ 10X \tFunction 10X - Exponential function of '10' (base: 10)
#-# Use\tCALCD.G4B number 10X\nRemarks\tPostfix function, existing result can be used instead of number\n\tHighest exponent < 18.9 (max result about 7.943exp18)\n\tAccuracy: about 18 digits, with very small powers less\nExample CALCD.G4B 10 10X\nExample CALCD.G4B 1.2555 10X\nExample CALCD.G4B 0.456 10X\nExample CALCD.G4B -0.456 10X\nExample CALCD.G4B 0.000000000123456789 10X\nExample CALCD.G4B 3!10X
if "%~2"=="" && set "message=Abort: number is missing before '%~1'" && goto :endlocal
shift
call :^ ^ 10 "%~1"
goto :endlocal
::
:ex
#-#+ EX \tFunction EX - Exponential function of 'e' (base: 2,718281828459045235)
#-# Use\tCALCD.G4B number EX\nRemarks\tPostfix function, existing result can be used instead of number\n\tHighest exponent < 44 (max result about 2.8516exp18)\n\tAccuracy: about 18 digits, with very small powers less\nExample CALCD.G4B 1 EX\nExample CALCD.G4B 10 EX\nExample CALCD.G4B 1.2555 EX\nExample CALCD.G4B 0.456 EX\nExample CALCD.G4B -0.456 EX\nExample CALCD.G4B 0.000000000123456789 EX\nExample CALCD.G4B 3!EX
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~1"=="goback" && set goback=Y && shift
if "%~2"=="" && set "message=Abort: number is missing before '%~0'" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal
shift
set N=%~1 && shift && set add=0 &; if /i %N:~-2,2%==mr && set N=%N:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %N%==r && set N=%R% ! if /i %N%==-r && set N=-%R%
#BAD#if %N:~0,1%==- && set "message=Bad input: check '%N%'" && goto :endlocal
if /i "%N:~-1,1%"=="!" && set N=%N:~0,-1% &; if %N:~0,1%==- && set N=%N1:~1% && set sign=- ! set sign= &; call :fact goback %N% &; if exist result && set N=%sign%%%result% && set result= && set sign= ! set rounded= && goto :endlocal
call :operatorsinput "%~0" "%N%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal
shift
if %N1%==1 && set ex=2.718281828459045235
if %N1%>=2 && set e=2.718281828459045235 && set result= &; call :^ ^ "%e%" "%N1%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set ex=%result% ! goto :endlocal
if not exist decimal1 && if %sign1%==-1 && set result= &; call :/ / 1 "%ex%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set ex=%result% ! goto :endlocal
if not exist decimal1 && if %goback%==Y && endlocal && set result=%ex% && set "message=%message%" && goto :eof
if not exist decimal1 && set result=%ex% && goto :endlocal
set N=0.%decimal1%
call :+ + 1 "%N%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set sum=%result% ! goto :endlocal
set exp=2
:eexponentiationloop
if %exp%<=9 && call :^ ^ "%N%" "%exp%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set power=%result% ! goto :endlocal
if %exp%>=10 && set /a exp2=%exp%/2 &; set /a exp1=%exp%-%exp2%
if %exp%>=10 && call :^ ^ "%N%" "%exp1%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set power=%result% ! goto :endlocal
if %exp%>=20 && if not %POWER%==0 &; if %exp%==20 && set /a fac2=20 ! if %exp%==21 && set /a fac2=20*21 ! if %exp%==22 && set /a fac2=20*21*22 ! if %exp%==23 && set /a fac2=20*21*22*23 ! if %exp%==24 && set /a fac2=20*21*22*23*24 ! if %exp%==25 && set /a fac2=20*21*22*23*24*25 ! if %exp%==26 && set /a fac2=20*21*22*23*24*25*26 ! if %exp%==27 && set /a fac2=20*21*22*23*24*25*26*27 ! if %exp%==28 && set /a fac2=20*21*22*23*24*25*26*27*28 ! if %exp%==29 && set /a fac2=20*21*22*23*24*25*26*27*28*29 ! if %exp%==30 && set /a fac2=20*21*22*23*24*25*26*27*28*29*30 ! if %exp%==31 && set /a fac2=20*21*22*23*24*25*26*27*28*29*30*31
#Division out of Range!#! if %exp%==32 && set /a fac=20*21*22*23*24*25*26*27*28*29*30*31*32
if %exp%<=19 &; if %exp%==2 && set fac1=2 ! if %exp%==3 && set fac1=6 ! if %exp%==4 && set fac1=24 ! if %exp%==5 && set fac1=120 ! if %exp%==6 && set fac1=720 ! if %exp%==7 && set fac1=5040 ! if %exp%==8 && set fac1=40320 ! if %exp%==9 && set fac1=362880 ! if %exp%==10 && set fac1=3628800 ! if %exp%==11 && set fac1=39916800 ! if %exp%==12 && set fac1=479001600 ! if %exp%==13 && set fac1=6227020800 ! if %exp%==14 && set fac1=87178291200 ! if %exp%==15 && set fac1=1307674368000 ! if %exp%==16 && set fac1=20922789888000 ! if %exp%==17 && set fac1=355687428096000 ! if %exp%==18 && set fac1=6402373705728000 ! if %exp%==19 && set fac1=121645100408832000
if %exp%<=19 && if not %POWER%==0 &; call :/ / "%power%" "%fac1%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set term=%result% ! goto :endlocal
if %exp%>=20 && if not %POWER%==0 &; call :/ / "%power%" "121645100408832000" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set term=%result% ! goto :endlocal
if not %POWER%==0 &; if %exp%>=10 && set result= && call :^ ^ "%N%" "%exp2%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set power=%result% ! goto :endlocal
if not %POWER%==0 &; if %exp%>=10 && set result= && call :* * "%power%" "%term%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set term=%result% ! goto :endlocal
if not %POWER%==0 &; if %exp%>=20 && call :/ / "%term%" "%fac2%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set term=%result% ! goto :endlocal
set result= && call :"==" "==" "%term%" "0" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if %result%==1 && set TERM=0 ! if not exist result && goto :endlocal
if not %TERM%==0 && set result= &; call :+ + "%sum%" "%term%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set sum=%result% ! goto :endlocal
if not %POWER%==0 && if not %TERM%==0 && if %exp%<=30 && set /a exp=%exp%+1 && set result= && set POWER= && set TERM= && goto :eexponentiationloop
if %N1%>=1 && set result= &; call :* * "%ex%" "%sum%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set sum=%result% ! goto :endlocal
if %sign1%==-1 && set result= &; call :/ / 1 "%sum%" &; if exist message && if %goback%==Y && endlocal && set "message=%message%" && goto :eof ! if exist message && goto :endlocal ! if exist result && set sum=%result% ! goto :endlocal
if %goback%==Y && endlocal && set result=%sum% && set "message=%message%" && goto :eof
set result=%sum% && goto :endlocal
::
:fraction2decimal
setlocal && set * && set rounded=%rounded% && set MR=%MR% && set lastrnd=%lastrnd% && set memrnd=%memrnd% && set R=%R% && set fix=%fix%
if "%~2"=="" && endlocal && set "message=Abort: number is missing before '%~1'" && goto :eof
call Fn.11 "%~2" ":" || endlocal && set "message=Abort: number '%~2' is not a valid fraction" && goto :eof
shift
set ARG=%~1 &; if not "%ARG:~0,1%"=="'" if not "%ARG:~0,1%"==":" if not "%ARG:~-1,1%"=="'" if not "%ARG:~-1,1%"==":" || endlocal && set "message=Abort: number '%ARG%' is not a valid fraction" && goto :eof
pause --wait=0 %ARG% > (md)0x300+1 &; raw cat --locate=\x27 (md)0x300+1 > nul &; if %@retval%>=2 && endlocal && set "message=Abort: number '%ARG%' is not a valid fraction" && goto :eof
raw cat --locate=\x3A (md)0x300+1 > nul &; if %@retval%>=2 && endlocal && set "message=Abort: number '%ARG%' is not a valid fraction" && goto :eof
raw cat --locate=\x27 (md)0x300+1 > nul &; set /a Alen=%?% &; cat --length=%Alen% (md)0x300+1 | set A= && set /a skip=%Alen%+1
raw cat --locate=\x3A (md)0x300+1 > nul &; if exist skip && set /a Blen=%?%-%skip% ! set /a Blen=%?% && set skip=0 &; cat --skip=%skip% --length=%Blen% (md)0x300+1 | set B= && set /a skip=%skip%+%Blen%+1 &; cat --skip=%skip% (md)0x300+1 | set C=
if not exist B if not exist C &; endlocal && set "message=Abort: number '%ARG%' is not a valid fraction" && goto :eof
if exist A && call :* * "%A%" "%C%" &; if exist result && call :+ + "%result%" "%B%" ! set result= &; if exist message && endlocal && set "message=%message%" && goto :eof ! set B=%result% && set result=
#SimpleButNotSafe#set /a B=%A% * %C% + %B%
call :/ / "%B%" "%C%"
endlocal && set result=%result% && set "message=%message%"
goto :eof
::
:abs
#-#+ ABS \tFunction ABS - Returns absolute value of number before (modulus)\n\tPostfix function\n\tExample: CALCD.G4B -8 CBRT ABS\n\tExample: CALCD.G4B -2^3ABS
setlocal && set *
if "%~2"=="" && set "message=Abort: number is missing before '%~0'" && set result= && goto :endlocal ! shift
set N=%~1 && shift && set add=0 &; if /i %N:~-2,2%==mr && set N=%N:~0,-2%%%MR% && set lastrnd=%memrnd% ! if /i %N%==r && set N=%R% ! if /i %N%==-r && set N=-%R%
if /i "%N:~-1,1%"=="!" && set N=%N:~0,-1% &; call :fact goback %N% &; if exist result && set N=%result% && set result= ! set rounded= && goto :endlocal
call :operatorsinput "%~0" "%N%" &; if exist message && set rounded= && goto :endlocal
if exist decimal1 && set result=%N1%.%decimal1% ! set result=%N1%
goto :endlocal
::
::==============================
# SUB-ROUTINE PARSESTRING #
::==============================
:parsestring
setlocal && set * && set DBG=%DBG%
if not exist DBG && set "NULL= > nul"
set /u "STRING=%*"
if %STRING:~0,2%==-- && set "STRING=%STRING:~2%" ! if %STRING:~0,2%==++ && set "STRING=%STRING:~2%" ! if %STRING:~0,2%==+- && set "STRING=%STRING:~1%" ! if %STRING:~0,2%==-+ && set "STRING=-%STRING:~2%"
if not exist NULL &; echo %0 STRING=$[0xf0]%STRING%
call Fn.11 "%STRING%" "SUM" &; call :parsestr --char=SUM %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" "PRODUCT" &; call :parsestr --char=PRODUCT %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" "MEAN" &; call :parsestr --char=MEAN %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" "VARP" &; call :parsestr --char=VARP %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" "VARS" &; call :parsestr --char=VARS %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" "STDEVP" &; call :parsestr --char=STDEVP %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" "STDEVS" &; call :parsestr --char=STDEVS %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" "FACT" &; call :parsestr --char=FACT %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" "PNR" &; call :parsestr --char=PNR %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" "CNR" &; call :parsestr --char=CNR %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" ""=="" && set prefix=Y
call Fn.11 "%STRING%" "">="" && set prefix=Y
call Fn.11 "%STRING%" ""<="" && set prefix=Y
call Fn.11 "%STRING%" "COUNTIF" &; call :parsestr --get=COUNTIF --set=countif %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" "countif" &; call :parsestr --char=countif %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "COUNT" &; call :parsestr --char=COUNT %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" "countif" &; call :parsestr --get=countif --set=COUNTIF %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "MIN" &; call :parsestr --char=MIN %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" "MAX" &; call :parsestr --char=MAX %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" "JOIN" &; call :parsestr --char=JOIN %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" "MD" &; call :parsestr --char=MD --skip=(MD) %STRING% &; set "STRING=%result%" && set result= && set prefix=Y
call Fn.11 "%STRING%" "ROUNDDOWN" &; call :parsestr --get=ROUNDDOWN --set=" DECI    " %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "ROUNDUP" &; call :parsestr --get=ROUNDUP --set=roundup %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "roundup" &; call :parsestr --char=roundup %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "ROUND" &; call :parsestr --char=ROUND %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "roundup" &; call :parsestr --get=roundup --set=ROUNDUP %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "DECI" &; call :parsestr --char=DECI %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "DIGI" &; call :parsestr --char=DIGI %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "FIX" &; call :parsestr --char=FIX %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "\\" &; call :parsestr --char="\\" %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "^" &; call :parsestr --char=^ %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "/" &; call :parsestr --char=/ %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "*" &; call :parsestr --char=* %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "--" &; call :parsestr --get=-- --set=++ %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "+-" &; call :parsestr --get=+- --set=-+ %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "-" &; call :parsestr --char=- --skip=" -" --same=-+ %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" "+" &; call :parsestr --char=+ --skip=" +" --same=++ %STRING% &; set "STRING=%result%" && set result=
if %prefix%==Y &; call Fn.11 "%STRING%" "+" &; call :parsestr --char=+ --skip=" +" --same=++ --na=(MD) %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "INV" &; call :parsestr --char=INV %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "SQRT" &; call :parsestr --get=SQRT --set=sqrt %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "sqrt" &; call :parsestr --char=sqrt %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "SQ" &; call :parsestr --char=SQ %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "sqrt" &; call :parsestr --get=sqrt --set=SQRT %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "CBRT" &; call :parsestr --get=CBRT --set=cbrt %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "cbrt" &; call :parsestr --char=cbrt %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "CB" &; call :parsestr --char=CB --skip=0XCB %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "cbrt" &; call :parsestr --get=cbrt --set=CBRT %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "LN" &; call :parsestr --char=LN %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "LOG" &; call :parsestr --char=LOG %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "MC" &; call :parsestr --char=MC %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "MS" &; call :parsestr --char=MS %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "MP" &; call :parsestr --char=MP %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "MN" &; call :parsestr --char=MN %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "SRM" &; call :parsestr --char=SRM %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "HEX" &; call :parsestr --get=HEX --set=hex %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "hex" &; call :parsestr --char=hex %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "EX" &; call :parsestr --char=EX %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "hex" &; call :parsestr --get=hex --set=HEX %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "10X" &; call :parsestr --get=10X --set=10x %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "10x" &; call :parsestr --char=10x %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "10x" &; call :parsestr --get=10x --set=10X %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "THSSEP" &; call :parsestr --get=THSSEP --set=" TS   " %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "THSEP" &; call :parsestr --get=THSEP --set=" TS  " %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "TSEP" &; call :parsestr --get=TSEP --set=" TS " %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "THSP" &; call :parsestr --get=THSP --set=" TS " %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "THS" &; call :parsestr --get=THS --set=" TS" %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "TS" &; call :parsestr --char=TS %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "BINS" &; call :parsestr --get=BINS --set=bins %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "bins" &; call :parsestr --char=bins %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "BIN" &; call :parsestr --char=BIN %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "ABS" &; call :parsestr --char=ABS %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" "* + " &; call :parsestr --get="* + " --set="*  +" %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" "* - " &; call :parsestr --get="* - " --set="*  -" %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" "/ + " &; call :parsestr --get="/ + " --set="/  +" %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" "/ - " &; call :parsestr --get="/ - " --set="/  -" %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" "ROUND + " &; call :parsestr --get="ROUND + " --set="ROUND  +" %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" "ROUND - " &; call :parsestr --get="ROUND - " --set="ROUND  -" %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" "ROUNDUP + " &; call :parsestr --get="ROUNDUP + " --set="ROUNDUP  +" %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" "ROUNDUP - " &; call :parsestr --get="ROUNDUP - " --set="ROUNDUP  -" %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" "DECI + " &; call :parsestr --get="DECI + " --set="DECI  +" %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" "DECI - " &; call :parsestr --get="DECI - " --set="DECI  -" %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" "DIGI + " &; call :parsestr --get="DIGI + " --set="DIGI  +" %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" "DIGI - " &; call :parsestr --get="DIGI - " --set="DIGI  -" %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" "FIX + " &; call :parsestr --get="FIX + " --set="FIX  +" %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" "FIX - " &; call :parsestr --get="FIX - " --set="FIX  -" %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" " + + " &; call :parsestr --get=" + + " --set="  +  " %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" " - - " &; call :parsestr --get=" - - " --set="  +  " %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" " + - " &; call :parsestr --get=" + - " --set="  -  " %STRING% &; set "STRING=%result%" && set result=
if not %prefix%==Y &; call Fn.11 "%STRING%" " - + " &; call :parsestr --get=" - + " --set="  -  " %STRING% &; set "STRING=%result%" && set result=
call Fn.11 "%STRING%" "bins" &; call :parsestr --get=bins --set=BINS %STRING% &; set "STRING=%result%" && set result=
set /l STRING=%STRING%
#BAD#if "%STRING%"=="0" && set STRING=
if not exist NULL &; echo %0 STRING=$[0xE0]%STRING%
endlocal && set "STRING=%STRING%"
goto :eof
::
:parsestr
setlocal
:parseswitches
if not exist char &; if /i "%~1"=="--char" && set "char=%~2" &; set /a charlen=%@retval% && shift && shift && goto :parseswitches
if not exist same &; if /i "%~1"=="--same" && set "same=%~2" &; set /a samelen=%@retval% && shift && shift && goto :parseswitches
if not exist skip &; if /i "%~1"=="--skip" && set "skip=%~2" &; set /a skiplen=%@retval% && shift && shift && goto :parseswitches
if not exist GET &; if /i "%~1"=="--get" && set "GET=%~2" &; set /a GETLEN=%@retval% && shift && shift && goto :parseswitches
if not exist SET &; if /i "%~1"=="--set" && set "SET=%~2" &; set /a SETLEN=%@retval% && shift && shift && goto :parseswitches
if not exist notafter &; if /i "%~1"=="--na" && set "notafter=%~2" &; set /a nalen=%@retval% && shift && shift && goto :parseswitches
set "STR= %*"
set /a strinlen=%@retval%
if not exist NULL && echo -n :parsestr STR=$[0xf0]%STR% &; if exist char && echo -n $[] char=$[0xf0]%char% ! set char= &; if exist skip && echo -n $[] skip=$[0xf0]%skip% ! set skip= &; if exist same && echo -n $[] same=$[0xf0]%same% ! set same= &; if exist char && echo -n $[] notafter=$[0xf0]%notafter% ! set notafter= &; if exist GET && echo $[] GET=$[0xf0]%GET%$[] SET=$[0xf0]%SET% ! echo
errorcheck off ;; if %STR:~0,1%"=="" && set start=DBQ
if not %start%==DBQ && if not "%STR:~0,1%"==" " && set "STR= %STR%" && set /a strinlen=%strinlen%+1 ! if %start%==DBQ && set "STR= %STR%" && set /a strinlen=%strinlen%+1 && set start=
errorcheck off ;; if %STR:~-1,1%"=="" && set end=DBQ
if not %end%==DBQ && if not "%STR:~-1,1%"==" " && set "STR=%STR% " && set /a strinlen=%strinlen%+1 ! if %end%==DBQ && set "STR=%STR% " && set /a strinlen=%strinlen%+1 && set end=
if not exist NULL && echo STR=$[0xf0]%STR%
if not exist ins && set "ins= " && set inslen=1
if not exist insalias && set insalias=? && set insallen=1
if not exist chralias && set challen=1 && set chralias=#
echo -n > (md)0x300+1
if exist skip &; if %challen%==1 && set "chralias=%chralias%" ! if %challen%==2 && set "chralias=%chralias%%%chralias%" ! if %challen%==3 && set "chralias=%chralias%%%chralias%%%chralias%" ! if %challen%==4 && set "chralias=%chralias%%%chralias%%%chralias%%%chralias%" ! if %challen%==5 && set "chralias=%chralias%%%chralias%%%chralias%%%chralias%%%chralias%" ! if %challen%==6 && set "chralias=%chralias%%%chralias%%%chralias%%%chralias%%%chralias%%%chralias%" ! if %challen%==7 && set "chralias=%chralias%%%chralias%%%chralias%%%chralias%%%chralias%%%chralias%%%chralias%"
if exist skip &; pause --wait=0 "%skip%" > (md)0x300+1 &; raw cat --locate=\x22\x0A --replace=\x00\x00 --number=1 (md)0x300+1 && raw cat --locate="%char%" --replace="%chralias%" (md)0x300+1 && raw cat (md)0x300+1 | set SKIP=
if exist skip &; set "SKIP=%SKIP:~1%"
echo -n > (md)0x300+1 && pause --wait=0 "%STR%" > (md)0x300+1 &; raw cat --locate=\x22 --replace=\x0A --number=1 (md)0x300+1 && raw cat --locate=\x22\x0A --replace=\x00\x00 --number=1 (md)0x300+1
if not exist NULL && cat --hex (md)0x300+1,32 && echo A
if exist GET && if exist SET &; raw cat --locate=\x0A --replace=\x22 --length=1 (md)0x300+1 && raw cat --locate="%GET%" --replace="%SET%" (md)0x300+1 && raw cat (md)0x300+1 | set str=
if not exist NULL && cat --hex (md)0x300+1,32 && echo B
if exist GET && if exist SET &; goto :cleanstr
if exist skip &; raw cat --locate="%skip%" --replace="%SKIP%" (md)0x300+1
#TooRestrictive#set "STR=%*" &; if %@retval%>=511 && echo Command-line %STR% is longer than 510 chars%NULL% && set result=0 && goto :eof
if %inslen%==1 && set "insalias=%insalias%" ! if %inslen%==2 && set "insalias=%insalias%%%insalias%" ! if %inslen%==3 && set "insalias=%insalias%%%insalias%%%insalias%" ! if %inslen%==4 && set "insalias=%insalias%%%insalias%%%insalias%%%insalias%" ! if %inslen%==5 && set "insalias=%insalias%%%insalias%%%insalias%%%insalias%%%insalias%" ! if %inslen%==6 && set "insalias=%insalias%%%insalias%%%insalias%%%insalias%%%insalias%%%insalias%" ! if %inslen%==7 && set "insalias=%insalias%%%insalias%%%insalias%%%insalias%%%insalias%%%insalias%%%insalias%"
set /a difflen=%samelen%-%charlen%
if exist same &; if %difflen%==0 && set "replsame=%char%" ! if %difflen%==1 && set replsame=%char%\x20 ! if %difflen%==2 && set replsame=%char%\x20\x20 ! if %difflen%==3 && set replsame=%char%\x20\x20\x20 ! if %difflen%==4 && set replsame=%char%\x20\x20\x20\x20 ! if %difflen%==5 && set replsame=%char%\x20\x20\x20\x20\x20 ! if %difflen%==6 && set replsame=%char%\x20\x20\x20\x20\x20\x20 ! if %difflen%==7 && set replsame=%char%\x20\x20\x20\x20\x20\x20\x20
if exist same &; raw cat --locate="%same%" --replace="%replsame%" (md)0x300+1 &; set /a numsame=%@retval% &; echo Number of '%same%': %numsame%%%NULL%
if exist notafter &; raw cat --locate="%notafter%" (md)0x300+1 > nul &; set /a skipna=%?% &; raw cat --skip=%skipna% --locate="%char%" --replace="%chralias%" --number=1 (md)0x300+1
set skipchar=1 && set done=0 && set numchar=0 && set string=
if "%char%"=="\\" && raw cat --skip=%skipchar% --locate=\x5C\x5C --length=%strinlen% (md)0x300+1 > nul ! raw cat --skip=%skipchar% --locate="%char%" --length=%strinlen% (md)0x300+1 > nul &; set /a numchar=%@retval%
:charsloop
if not exist NULL && echo :charsloop skipchar=%skipchar% skipchar=%skipchar% done=%done% string=$[0xf0]%string%
if %numchar%>=1 && if not %done%==%numchar% &; raw cat --skip=%skipchar% --locate="%char%" --number=1 (md)0x300+1 > nul &; set /a skiplen=%?%-%skipchar% &; raw cat --skip=%skipchar% --length=%skiplen% (md)0x300+1 | set string=%string% &; set "string=%string%%%insalias%%%char%%%insalias%" && set /a skipchar=%skipchar%+%skiplen%+%charlen% && set /a done=%done%+1 && goto :charsloop
if %numchar%>=1 && if %done%==%numchar% &; raw cat --skip=%skipchar% (md)0x300+1 | set string=%string%
if %numchar%>=1 && if %done%==%numchar% &; echo -n > (md)0x300+1 && pause --wait=0 "%string%" > (md)0x300+1 &; raw cat --locate=\x22\x0A --replace=\x00\x00 --number=1 (md)0x300+1
if %numchar%==0 && raw cat --locate=\x0A --replace=\x22 --length=1 (md)0x300+1
if not exist NULL && echo done=%done% string=$[0xf0]%string%
if not exist NULL && cat (md)0x300+1 && echo
if not "%char%"=="\\" && raw cat --locate="%insalias%" --replace="%ins%" (md)0x300+1
if "%char%"=="\\" && raw cat --locate="%insalias%\x5C\x5C%insalias%" --replace="%ins%\x5C\x5C%ins%" (md)0x300+1
if exist skip &; raw cat --locate="%SKIP%" --replace="%skip%" (md)0x300+1
if exist notafter &; raw cat --locate="%chralias%" --replace="%char%" (md)0x300+1
raw cat --locate=\x0A --replace=\x22 --length=1 (md)0x300+1
:cleanstr
raw cat --locate="%ins%%%ins%" (md)0x300+1 > nul && raw cat --locate=\x22 --replace=\x20 --length=1 (md)0x300+1 && raw cat (md)0x300+1 | call :clean &; echo -n > (md)0x300+1 && pause --wait=0 "%clean%" > (md)0x300+1 && raw cat --locate=\x22\x0A --replace=\x00\x00 --number=1 (md)0x300+1
if not exist NULL && cat --hex (md)0x300+1,32 && echo D
raw cat (md)0x300+1 | set str=
if not exist NULL && echo A str=$[0xf0]%str%
set "str=%str:~1%"
if not exist NULL && echo B str=$[0xf0]%str%
errorcheck off ;; if %str:~-1,1%"=="" && set start=DBQ
if not %start%==DBQ && if "%str:~0,1%"==" " && set "str=%str:~1%"
errorcheck off ;; if %str:~-1,1%"=="" && set end=DBQ
if not %end%==DBQ && if "%str:~-1,1%"==" " && set "str=%str:~0,-1%"
if not exist NULL && echo C str=$[0xf0]%str%
endlocal && set "result=%str%"
if not exist NULL && echo %0 result=$[0xd0]%result%
goto :eof
::
:clean
if not exist NULL && echo :clean %*
if not exist NULL && echo :clean $[0xf0]%1
if not exist NULL && echo :clean $[0x0F]%1
set "ARG=%1" &; if not exist ARG && goto :eof
#BAD#if "%1"=="" && echo $[0xE0]GO && goto :eof
if not exist NULL && echo :clean $[0x0E]%1
if not exist clean && set "clean=%1" ! set "clean=%clean%%%ins%%%1"
if not exist NULL && echo  %0 clean=$[0xf0]%clean%
set ARG= && shift
goto :clean
::
::==============================
# END SUB-ROUTINE PARSESTRING #
::==============================
:help
setlocal
debug status > nul ;; set /a debugsts=%@retval% > nul && debug 1 && debug msg=3
pager status > nul ;; set /a pagersts=%@retval% > nul && pager on
if not "%~2"=="" && set EXT=%~x0 && set DEVICE=%~d0 && set PATH=%~p0 &; if exist EXT && set FILE=%~nx0 && set EXT= ! set FILE=%~n0.g4b && set EXT= &; if %DEVICE%==(md) && set FILE=%PATH%%%FILE% && set DEVICE= && set PATH= ! set FILE=%DEVICE%%%PATH%%%FILE% && set DEVICE= && set PATH=
if exist FILE && set EOL=\x0A &; cat --skip=0 --locate=!BAT%EOL% --length=5 %FILE% > nul |; cat --skip=0 --locate=!BAT\x0D%EOL% --length=6 %FILE% > nul |; set EOL=\x0D &; cat --skip=0 --locate=!BAT%EOL% --length=5 %FILE% > nul |; set FILE=
if exist FILE && cat --locatei=#-#+\x20%~2\x20 %FILE% > nul &; set /A start=%?%+6 > nul &; cat --skip=%start% --locate=\x20 --number=1 %FILE% > nul &; set /A start=%?%+1 > nul &; cat --skip=%start% --locate=%EOL% --number=1 %FILE% > nul &; set /A echolen=%?%-%start% > nul &; cat --skip=%start% --length=%echolen% %FILE% | echo -e Help\x20
if exist FILE && set /A start=%start%+%echolen% > nul &; cat --skip=%start% --locate=%EOL%#-#\x20 --length=5 %FILE% > nul &; set /A start=%?%+4 > nul &; cat --skip=%start% --locate=%EOL% --number=1 %FILE% > nul &; set /A echolen=%?%-%start% > nul &; cat --skip=%start% --length=%echolen% %FILE% | echo -e
if exist FILE &; if %pagersts%==1 && pager on ! pager off
if exist FILE && endlocal && goto :eof
if not "%~2"=="" && goto :help%~2
echo -e Help\tCALCD.G4B v0.3.2 (20240613), by deomsh
echo -e Output\tResult echood and if exists in variables result R MR lastrnd or message
echo -e Prefix\tFunctions: SUM  PRODUCT  MEAN  VARP  VARS  STDEVP  STDEVS  FACT  Pnr\n\t\           Cnr  "=="  ">="  "<="  COUNT MAX MIN COUNTIF JOIN
echo -e Use\tCALCD.G4B [switches] function number1 [number2]\x20|\x20args
echo -e Infix\tOperators:  +   -   *   /  ^   Functions: ROUNDUP ROUND DECI DIGI FIX
echo -e Use\tCALCD.G4B [switches] number1 operator|function number2|NUMBER
echo -e Postfix\tFunctions: INV SQRT SQ CBRT CB LN EX LOG 10X ABS HEX BIN[S] THSEP|TS
echo -e Use\tCALCD.G4B [switches] number function
echo -e Memory\tFunctions: MS  MP (M+)  MN (M-)  SRM (R/M)  MC (clear)  MR R (numbers)
echo -e Help\tCALCD.G4B help|--help|/? [function|operator|mem|ver]
echo -e Switch\t--no-parse (use spaces around operators and funcions!)
echo -e Switch\t--echo|--echoM|--echoR|--V|--Q|/Q (V:debug msg=3; Q:quiet)
echo -e Remarks\tNumbers: \xF110exp-18-2exp63-1 a'b:c 0!-20! en (2.7182818284590..) pi MR R\n\tIntegers in hex (starting with 0x) and bin (starting with 0b) supported\n\tFractions supported as a'b:c (a>=1, like 1'1:4 = 1 1:4 - b/c divides!)\n\tPost-operators k, m and g allowed - after decimals too (one per number)\n\tNumbers pi and e can be used as post-operators too (one per number)\n\tThousand-comma-separator allowed. Decimals: dot, NOT comma (no hex/bin)\n\tDecimal output unless HEX/ BIN[S] is used, no fractions/ post-operators\n\tOrder of calculation: from left to right. NO brackets allowed\n\tError-messages are echood, while 'result' is deleted (last result: 'R')
echo -e \tContinue calculation: infix/postfix operator/function with last result\n\tRestart: prefix function OR number with infix/postfix operator/function\n\tMemory functions do not interrupt calculation (SRM exchanges R and MR)\n\tNames/ switches case-insensitive, variables are case-sensitive!\n\tEnding COUNT and JOIN: with \\\\ only\n\tWatch double-quotes in prefix functions "=="  ">="  "<="
echo -e Prefix\tFunctions SUM PRODUCT MEAN VARP VARS STDEVP STDEVS MIN MAX COUNTIF JOIN\n\tbefore at least two numbers, COUNT >= 1 argument ( \\\\ not counted)\n\t\Instead of numbers FILE is taken too, FILE: (md)-device, max 255\n\t sectors - each argument separated by spaces (20), 0A, 0D0A and 00\n\tFACT (Factorial) one integer: 0-20. Pnr (Permutation) and Cnr (Combina-\n\ttion) two integers: n and r (n: 1-20 and r: 0-20)\n\tCompare: "==" ">=" "<=" (double qoutes mandatory!) needs two numbers\n\tArguments of prefix functions are never parsed (needs spaces)
echo -e Infix\tOperators + - * / between number/ existing result and second number\n\tOperator ^ between number/result and exponent\n\tFunctions ROUND[UP] and DECI (=down) between number/ result and integer\n\t(negative: rounds integers). DIGI (rounds) sets number of digits\n\t(negative: less digits). FIX (rounds) sets number of decimals/ zeros\n\tAlias of DECI:  ROUNDDOWN
echo -e Postfix\tFunctions INV (inverse) SQRT (square root) SQ (square) CBRT\n\t(cubic root) CB (cubic) LN LOG EX 10X HEX BIN[S] THSEP come after one\n\tnumber/ result. HEX and BIN[S]: no rounding, cut-off decimals only\n\tHEX and BIN[S]: negative numbers in Two's Complement format (64-bits)\n\tTHSEP: adds thousand-comma-separator to last result - use as last\n\tcommand only, earlier ignored! Overrules HEX/ BIN[S]\n\tAliasses of THSEP:  TS  THS  THSP  TSEP  THSSEP
echo -e Parsing\tAfter a memory or postfix function + or - before a number is not parsed\n\tExample 1: 2 INV -1 restarts calculation, use 2 INV - 1 or 2INV-1\n\tExample 2: 2+3 MS -7 restarts calculation, use 2+3 MS - 7 or 2+3MS-7\n\tPrefix functions "=="  ">="  "<=" can not be parsed, use spaces around!
echo -e Example CALCD.G4B help ^
echo -e Example CALCD.G4B help LN
echo -e Example CALCD.G4B help STDEVP
echo -e Example CALCD.G4B --help THSEP
echo -e Example CALCD.G4B /? mem
echo -e Example CALCD.G4B 38 + 2.5 - -27.315 * 1.2895 / -3.1234 ^ 4 SQRT
echo -e Example CALCD.G4B 38+2.5--27.315*1.2895/-3.1234^4SQRT
echo -e Example CALCD.G4B --echo SUM 3.4 2.3 1.2 / 3 MS STDEVP 0.5 1 2 MP MR ROUND 5
echo -e Example CALCD.G4B 1 SQRT MS 4 SQRT MP 9 SQRT MP 16 SQRT MP 25 SQRT MP MR
echo -e Example CALCD.G4B MEAN 1.15 2.15 3.15
echo -e Example echo\x201.15 2.15 3.15\x20>\x20(md)0x300+1\x20;;\x20CALCD.G4B --Q MD MEAN (md)0x300+1\n\t\x20;;\x20set result
echo -e Example CALCD.G4B 1.5 * 1k
echo -e Example CALCD.G4B 1.5k
echo -e Example CALCD.G4B 1k.5
echo -e Example CALCD.G4B 1.5en
echo -e Example CALCD.G4B 1.5pi
echo -e Example CALCD.G4B 1'1:2en
echo -e Example CALCD.G4B 1'1:2pi
if %pagersts%==1 && pager on ! pager off
if exist debugsts && debug %debugsts% > nul
endlocal && goto :eof
::
:smallhelp
echo -e Prefix\t Functions: SUM PRODUCT MEAN VARP VARS STDEVP STDEVS FACT Pnr Cnr\n\t\             "==" ">=" "<=" COUNT MAX MIN COUNTIF JOIN
echo -e Use\t CALCD.G4B [switches] function number1 [number2]\x20|\x20arguments
echo -e Switches --no-parse --echo|--echoM|--echoR|--V|--Q|/Q
echo -e Infix\t Operators: + - * / ^  Functions: ROUNDUP ROUND DECI DIGI FIX
echo -e Use\t CALCD.G4B [switches] number1 operator|function number2|NUMBER
echo -e Postfix\t Functions: INV SQRT SQ CBRT CB LN EX LOG 10X ABS HEX BIN[S] THSEP|TS
echo -e Use\t CALCD.G4B [switches] number function
echo -e Memory\t Functions: MS  MP (M+)  MN (M-)  SRM (R/M)  MC (clear)  MR R (numbers)
echo -e Numbers\t \xF110exp-18-2exp63-1 a'b:c 0!-20! en pi MR R Hex/Bin 64bits decimals dot
echo -e Help\t CALCD.G4B help|--help|/? [function|operator|mem|ver]
goto :eof
::
#-#+ mem \tMEMORY - Functions: MS  MP (M+)  MN (M-)  SRM (switch R/M)  MC (clear)\n\tPlaceholders for number: MR (memory read) R (last result)
#-# Use 1\tCALCD.G4B [switches] [MC] number MS|MP|MN\nUse 2\tCALCD.G4B [switches] [MC] R MS|MP|MN\nUse 3\tCALCD.G4B [switches] MR\nUse 4\tCALCD.G4B [switches] function MR number R\nUse 5\tCALCD.G4B [switches] MR function\nUse 6\tCALCD.G4B [switches] MR function number\nUse 7\tCALCD.G4B [switches] number function MR\nUse 8\tCALCD.G4B [switches] [MC] number MS|MP|MN function number SRM\nRemarks\tPostfix functions, existing result can be used instead of number\n\tMC/ MS/ MP/ MN resets/ writes/ adds/ substract number/ result to memory\n\tMR is memory-read, used as number. SRM exchanges result and memory\n\tSRM needs existing variable 'result', before or during calculation\n\tIf variable 'MR' not exist: 'MR' is set to '0'. 'R' is placeholder for\n\texisting variable 'result', before (next) use of CALCD.G4B (or zero!)\n\tIf 'MR' or 'R' contains integer 0-20, use of MR! or R! is allowed\n\tWriting to memory with MC|MS|MP|MN|SRM will not interrupt calculation\n\tSwitch --echoM echos changing MR, --echoR echos changing R, --echo both\n\tVariables 'MR' and 'R' are exported/ imported by CALCD.G4B (case!)\nExample CALCD.G4B MC 8 * 7 MP MR\nExample CALCD.G4B --echo 20 - 13 R! MS\x20;;\x20CALCD.G4B --echo 10! / MR SRM / MR\nExample CALCD.G4B --echoR SUM 7 8 MS PRODUCT 7 8 + MR / 7 MP MR ROUND 4\nExample set MR=\x20;;\x20CALCD.G4B --echoM 2 ^ 62 MS - 1 MP\x20;;\x20CALCD.G4B MR
::
#-#+ VER \t  VERSIONS of specific functions in historical order
#-# Operator: SUMMATION '+' v.0.1.9 (20220914)\nOperator: SUBSTRACTION '-' v.0.1.8 (20220914)\nOperator: MULTIPLICATION '*' v.0.1.9 (20220918)\nOperator: DIVISION '/' v.0.2 (20240610)\nOperator: EXPONENTATION '^' v.0.2 (20240529)\nFunction: SQUARE ROOT 'SQRT' v.0.1.9 (20220921)\nFunction: INVERSE 'INV' v.0.1.2 (20220731)\nFunction: SUM v.0.1.4 (20220730)\nFunction: COUNT v.0.1.5 (20220815)\nFunction: PRODUCT v.0.1.2 (20220729)\nFunction: MEAN v.0.1.2 (20220731)\nFunction: FACTORIAL 'FACT' v.0.2 (20240531)\nFunction: VARIATION in population 'VARP' v.0.1.1 (20220730)\nFunction: VARIATION in sample 'VARS' v.0.1.1 (20220730)\nFunction: STANDARDDEVIATION in population 'STDEVP' v.0.1.1 (20220730)\nFunction: STANDARDDEVIATION in sample 'STDEVS' v.0.1.1 (20220730)\nFunction: EQUAL ' "==" ' v.0.1.2 (20220903)\nFunction: EQUAL or GREATER ' ">=" ' v.0.1.2 (20220904)\nFunction: EQUAL or SMALLER ' "<=" ' v.0.1.2 (20220904)\nFunction: PERMUTATION 'Pnr' v.0.1.1 (20220811)\nFunction: COMBINATION 'Cnr'v.0.1.1 (20220811)\nFunction: ROUND v.0.1.5 (20220917)\nFunction: ROUNDDOWN 'DECI' v.0.1.5 (20220925)\nFunction: Set number of digits 'DIGI' v.0.1.3 (20220914)\nFunction: Set number of decimals 'FIX' v.0.1.3 (20220925)\nFunction: CUBIC ROOT 'CBRT' v.0.1.3 (20221009)\nFunction: HEX v.0.2 (20240611)\nFunction: SQUARE 'SQ' v.0.1 (20221001)\nFunction: CUBIC 'CB' v.0.1 (20221001)\nFunction: Thousand separator 'THSEP|TS' v.0.1.2 (20230112)\nFunction: MIN v.0.1 (20221125)\nFunction: MAX v.0.1 (20221125)\nFunction: COUNTIF v.0.1 (20221125)\nFunction: ROUNDUP v.0.1 (20240202)\nFunction: BIN[S] v0.2 (20240611)\nFunction: JOIN v0.1 (20240524)\nFunction: LN & LOG v0.1 (20240602)\nFunction: EX & 10X v0.1 (20240529)\nNumbers: pi & en (Eulers Number) v0.1.1 (20240610)\nPost-operators: k, m, g, pi & en v0.1.2 (20240610)\nFractions: a'b:c v0.1.1 (20240608)\nFunction: MODULUS 'ABS' v0.1 (20240610)
